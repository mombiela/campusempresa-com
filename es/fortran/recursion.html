<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy<br> y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<b id="lit_lang_es">Castellano</b>
				|
				<a href="https://campusempresa.cat/fortran/recursion" id="lnk_lang_ca" data-lang="ca">Català</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="objective">El Proyecto</a>
				<a href="about">Sobre nosotros</a>
				<a href="contribute">Contribuir</a>
				<a href="donate">Donaciones</a>
				<a href="licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introducción a la Recursión</h1>
<div class='content'><p>La recursión es una técnica de programación donde una función se llama a sí misma para resolver un problema. Es particularmente útil para problemas que pueden descomponerse en subproblemas más pequeños y similares. En Fortran, la recursión puede implementarse utilizando funciones recursivas.</p>
</div><h2>Conceptos Clave</h2>
<div class='content'><ul>
<li><strong>Caso Base</strong>: La condición bajo la cual la función recursiva deja de llamarse a sí misma.</li>
<li><strong>Caso Recursivo</strong>: La parte de la función donde la función se llama a sí misma con un argumento modificado.</li>
<li><strong>Desbordamiento de Pila</strong>: Un riesgo potencial cuando la profundidad de la recursión es demasiado alta, lo que lleva a un uso excesivo de memoria.</li>
</ul>
</div><h1>Ejemplo Básico de Recursión</h1>
<div class='content'><p>Comencemos con un ejemplo simple: calcular el factorial de un número.</p>
</div><h2>Función Factorial</h2>
<div class='content'><p>El factorial de un número \( n \) (denotado como \( n! \)) es el producto de todos los enteros positivos menores o iguales a \( n \). El factorial de 0 se define como 1.</p>
<h4>Ejemplo de Código</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHJvZ3JhbSBmYWN0b3JpYWxfZXhhbXBsZQogICAgaW1wbGljaXQgbm9uZQogICAgaW50ZWdlciA6OiBuLCByZXN1bHQKCiAgICBwcmludCAqLCAiRW50ZXIgYSBudW1iZXI6IgogICAgcmVhZCAqLCBuCgogICAgcmVzdWx0ID0gZmFjdG9yaWFsKG4pCiAgICBwcmludCAqLCAiRmFjdG9yaWFsIG9mICIsIG4sICIgaXMgIiwgcmVzdWx0CmVuZCBwcm9ncmFtIGZhY3RvcmlhbF9leGFtcGxlCgpyZWN1cnNpdmUgZnVuY3Rpb24gZmFjdG9yaWFsKG4pIHJlc3VsdChmYWN0KQogICAgaW50ZWdlciwgaW50ZW50KGluKSA6OiBuCiAgICBpbnRlZ2VyIDo6IGZhY3QKCiAgICBpZiAobiA8PSAxKSB0aGVuCiAgICAgICAgZmFjdCA9IDEKICAgIGVsc2UKICAgICAgICBmYWN0ID0gbiAqIGZhY3RvcmlhbChuIC0gMSkKICAgIGVuZCBpZgplbmQgZnVuY3Rpb24gZmFjdG9yaWFs"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>program factorial_example
    implicit none
    integer :: n, result

    print *, &quot;Enter a number:&quot;
    read *, n

    result = factorial(n)
    print *, &quot;Factorial of &quot;, n, &quot; is &quot;, result
end program factorial_example

recursive function factorial(n) result(fact)
    integer, intent(in) :: n
    integer :: fact

    if (n &lt;= 1) then
        fact = 1
    else
        fact = n * factorial(n - 1)
    end if
end function factorial</pre></div><div class='content'></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Caso Base</strong>: Cuando \( n \leq 1 \), la función devuelve 1.</li>
<li><strong>Caso Recursivo</strong>: La función se llama a sí misma con \( n - 1 \) y multiplica el resultado por \( n \).</li>
</ul>
</div><h1>Ejemplo Avanzado de Recursión</h1>
<div class='content'><p>Exploremos un ejemplo más complejo: la secuencia de Fibonacci.</p>
</div><h2>Secuencia de Fibonacci</h2>
<div class='content'><p>La secuencia de Fibonacci es una serie de números donde cada número es la suma de los dos anteriores, usualmente comenzando con 0 y 1.</p>
<h4>Ejemplo de Código</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHJvZ3JhbSBmaWJvbmFjY2lfZXhhbXBsZQogICAgaW1wbGljaXQgbm9uZQogICAgaW50ZWdlciA6OiBuLCBpCgogICAgcHJpbnQgKiwgIkVudGVyIHRoZSBudW1iZXIgb2YgdGVybXM6IgogICAgcmVhZCAqLCBuCgogICAgZG8gaSA9IDAsIG4tMQogICAgICAgIHByaW50ICosICJGaWJvbmFjY2koIiwgaSwgIikgPSAiLCBmaWJvbmFjY2koaSkKICAgIGVuZCBkbwplbmQgcHJvZ3JhbSBmaWJvbmFjY2lfZXhhbXBsZQoKcmVjdXJzaXZlIGZ1bmN0aW9uIGZpYm9uYWNjaShuKSByZXN1bHQoZmliKQogICAgaW50ZWdlciwgaW50ZW50KGluKSA6OiBuCiAgICBpbnRlZ2VyIDo6IGZpYgoKICAgIGlmIChuID09IDApIHRoZW4KICAgICAgICBmaWIgPSAwCiAgICBlbHNlaWYgKG4gPT0gMSkgdGhlbgogICAgICAgIGZpYiA9IDEKICAgIGVsc2UKICAgICAgICBmaWIgPSBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKQogICAgZW5kIGlmCmVuZCBmdW5jdGlvbiBmaWJvbmFjY2k="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>program fibonacci_example
    implicit none
    integer :: n, i

    print *, &quot;Enter the number of terms:&quot;
    read *, n

    do i = 0, n-1
        print *, &quot;Fibonacci(&quot;, i, &quot;) = &quot;, fibonacci(i)
    end do
end program fibonacci_example

recursive function fibonacci(n) result(fib)
    integer, intent(in) :: n
    integer :: fib

    if (n == 0) then
        fib = 0
    elseif (n == 1) then
        fib = 1
    else
        fib = fibonacci(n - 1) + fibonacci(n - 2)
    end if
end function fibonacci</pre></div><div class='content'></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Casos Base</strong>: Cuando \( n = 0 \), la función devuelve 0. Cuando \( n = 1 \), la función devuelve 1.</li>
<li><strong>Caso Recursivo</strong>: La función se llama a sí misma con \( n - 1 \) y \( n - 2 \) y suma los resultados.</li>
</ul>
</div><h1>Optimización de la Recursión</h1>
<div class='content'><p>La recursión puede ser ineficiente para problemas como la secuencia de Fibonacci debido a cálculos repetidos. Una forma de optimizar es utilizando memoización o enfoques iterativos.</p>
</div><h2>Ejemplo de Memoización</h2>
<div class='content'><p>La memoización implica almacenar los resultados de llamadas a funciones costosas y reutilizarlos cuando los mismos inputs ocurren nuevamente.</p>
<h4>Ejemplo de Código</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHJvZ3JhbSBmaWJvbmFjY2lfbWVtb2l6YXRpb25fZXhhbXBsZQogICAgaW1wbGljaXQgbm9uZQogICAgaW50ZWdlciwgcGFyYW1ldGVyIDo6IG1heF9uID0gMTAwCiAgICBpbnRlZ2VyIDo6IG4sIGkKICAgIGludGVnZXIsIGRpbWVuc2lvbigwOm1heF9uKSA6OiBtZW1vCgogICAgbWVtbyA9IC0xCgogICAgcHJpbnQgKiwgIkVudGVyIHRoZSBudW1iZXIgb2YgdGVybXM6IgogICAgcmVhZCAqLCBuCgogICAgZG8gaSA9IDAsIG4tMQogICAgICAgIHByaW50ICosICJGaWJvbmFjY2koIiwgaSwgIikgPSAiLCBmaWJvbmFjY2lfbWVtbyhpLCBtZW1vKQogICAgZW5kIGRvCmVuZCBwcm9ncmFtIGZpYm9uYWNjaV9tZW1vaXphdGlvbl9leGFtcGxlCgpyZWN1cnNpdmUgZnVuY3Rpb24gZmlib25hY2NpX21lbW8obiwgbWVtbykgcmVzdWx0KGZpYikKICAgIGludGVnZXIsIGludGVudChpbikgOjogbgogICAgaW50ZWdlciwgZGltZW5zaW9uKDopLCBpbnRlbnQoaW5vdXQpIDo6IG1lbW8KICAgIGludGVnZXIgOjogZmliCgogICAgaWYgKG1lbW8obikgLz0gLTEpIHRoZW4KICAgICAgICBmaWIgPSBtZW1vKG4pCiAgICBlbHNlCiAgICAgICAgaWYgKG4gPT0gMCkgdGhlbgogICAgICAgICAgICBmaWIgPSAwCiAgICAgICAgZWxzZWlmIChuID09IDEpIHRoZW4KICAgICAgICAgICAgZmliID0gMQogICAgICAgIGVsc2UKICAgICAgICAgICAgZmliID0gZmlib25hY2NpX21lbW8obiAtIDEsIG1lbW8pICsgZmlib25hY2NpX21lbW8obiAtIDIsIG1lbW8pCiAgICAgICAgZW5kIGlmCiAgICAgICAgbWVtbyhuKSA9IGZpYgogICAgZW5kIGlmCmVuZCBmdW5jdGlvbiBmaWJvbmFjY2lfbWVtbw=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>program fibonacci_memoization_example
    implicit none
    integer, parameter :: max_n = 100
    integer :: n, i
    integer, dimension(0:max_n) :: memo

    memo = -1

    print *, &quot;Enter the number of terms:&quot;
    read *, n

    do i = 0, n-1
        print *, &quot;Fibonacci(&quot;, i, &quot;) = &quot;, fibonacci_memo(i, memo)
    end do
end program fibonacci_memoization_example

recursive function fibonacci_memo(n, memo) result(fib)
    integer, intent(in) :: n
    integer, dimension(:), intent(inout) :: memo
    integer :: fib

    if (memo(n) /= -1) then
        fib = memo(n)
    else
        if (n == 0) then
            fib = 0
        elseif (n == 1) then
            fib = 1
        else
            fib = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
        end if
        memo(n) = fib
    end if
end function fibonacci_memo</pre></div><div class='content'></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Array Memo</strong>: Un array <code>memo</code> se utiliza para almacenar los resultados de los cálculos de Fibonacci.</li>
<li><strong>Verificar Memo</strong>: Antes de realizar una llamada recursiva, la función verifica si el resultado ya está en el array memo.</li>
</ul>
</div><h1>Conclusión</h1>
<div class='content'><p>La recursión es una herramienta poderosa en Fortran para resolver problemas que pueden descomponerse en subproblemas más pequeños. Sin embargo, es importante manejar correctamente los casos base para evitar recursión infinita y potencial desbordamiento de pila. Para problemas complejos, optimizar la recursión con técnicas como la memoización puede mejorar significativamente el rendimiento. Al entender y aplicar estos conceptos, puedes usar efectivamente la recursión en tus programas en Fortran.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
       <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
       <a href="cookies">Més informació</a>
   </div>	
	</div>    
</body>
</html>
