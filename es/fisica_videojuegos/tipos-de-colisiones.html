<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tipos de Colisiones</title>

    <link rel="alternate" href="https://campusempresa.com/es/fisica_videojuegos/tipos-de-colisiones" hreflang="es" />
    <link rel="alternate" href="https://campusempresa.com/es/fisica_videojuegos/tipos-de-colisiones" hreflang="x-default" />
	<link rel="alternate" href="https://campusempresa.com/ca/fisica_videojuegos/tipos-de-colisiones" hreflang="ca" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/es/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy<br> y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<b id="lit_lang_es" class="px-2">ES</b>
				|
				<a href="/ca/fisica_videojuegos/tipos-de-colisiones" id="lnk_lang_ca" data-lang="ca" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="objective">El Proyecto</a>
				<a href="about">Sobre nosotros</a>
				<a href="contribute">Contribuir</a>
				<a href="donate">Donaciones</a>
				<a href="licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'><p>En la física de videojuegos, las colisiones son fundamentales para crear interacciones realistas entre objetos. Este tema cubre los diferentes tipos de colisiones que se pueden implementar en un motor de juego, sus características y cómo se pueden manejar programáticamente.</p>
</div><h1>Colisiones AABB (Axis-Aligned Bounding Box)</h1>
<div class='content'><p>Las colisiones AABB son uno de los métodos más simples y eficientes para detectar colisiones entre objetos en un videojuego. Estas colisiones utilizan cajas delimitadoras alineadas con los ejes para simplificar los cálculos.</p>
<ul>
<li>
<p><strong>Características</strong>:</p>
<ul>
<li>Las cajas están alineadas con los ejes del sistema de coordenadas.</li>
<li>Fácil de implementar y computacionalmente eficiente.</li>
<li>Ideal para objetos rectangulares o cúbicos.</li>
</ul>
</li>
<li>
<p><strong>Ejemplo de Código</strong>:</p>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Y2xhc3MgQUFCQjoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KToKICAgICAgICBzZWxmLnggPSB4CiAgICAgICAgc2VsZi55ID0geQogICAgICAgIHNlbGYud2lkdGggPSB3aWR0aAogICAgICAgIHNlbGYuaGVpZ2h0ID0gaGVpZ2h0CgpkZWYgY2hlY2tfY29sbGlzaW9uKGEsIGIpOgogICAgcmV0dXJuIChhLnggPCBiLnggKyBiLndpZHRoIGFuZAogICAgICAgICAgICBhLnggKyBhLndpZHRoID4gYi54IGFuZAogICAgICAgICAgICBhLnkgPCBiLnkgKyBiLmhlaWdodCBhbmQKICAgICAgICAgICAgYS55ICsgYS5oZWlnaHQgPiBiLnkpCgojIEVqZW1wbG8gZGUgdXNvCmJveDEgPSBBQUJCKDAsIDAsIDEwLCAxMCkKYm94MiA9IEFBQkIoNSwgNSwgMTAsIDEwKQpwcmludChjaGVja19jb2xsaXNpb24oYm94MSwgYm94MikpICAjIERlYmVyw61hIGltcHJpbWlyIFRydWU="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>class AABB:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

def check_collision(a, b):
    return (a.x &lt; b.x + b.width and
            a.x + a.width &gt; b.x and
            a.y &lt; b.y + b.height and
            a.y + a.height &gt; b.y)

# Ejemplo de uso
box1 = AABB(0, 0, 10, 10)
box2 = AABB(5, 5, 10, 10)
print(check_collision(box1, box2))  # Deber&iacute;a imprimir True</pre></div><div class='content'></div><h1>Colisiones Circulares</h1>
<div class='content'><p>Las colisiones circulares son útiles para objetos que tienen una forma redonda o esférica. Este método utiliza la distancia entre los centros de los círculos para determinar si hay una colisión.</p>
<ul>
<li>
<p><strong>Características</strong>:</p>
<ul>
<li>Adecuado para objetos redondos.</li>
<li>Requiere el cálculo de la distancia entre dos puntos.</li>
<li>Puede ser más costoso computacionalmente que AABB para objetos no circulares.</li>
</ul>
</li>
<li>
<p><strong>Ejemplo de Código</strong>:</p>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IG1hdGgKCmNsYXNzIENpcmNsZToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4LCB5LCByYWRpdXMpOgogICAgICAgIHNlbGYueCA9IHgKICAgICAgICBzZWxmLnkgPSB5CiAgICAgICAgc2VsZi5yYWRpdXMgPSByYWRpdXMKCmRlZiBjaGVja19jb2xsaXNpb24oY2lyY2xlMSwgY2lyY2xlMik6CiAgICBkaXN0YW5jZSA9IG1hdGguc3FydCgoY2lyY2xlMS54IC0gY2lyY2xlMi54KSAqKiAyICsgKGNpcmNsZTEueSAtIGNpcmNsZTIueSkgKiogMikKICAgIHJldHVybiBkaXN0YW5jZSA8IChjaXJjbGUxLnJhZGl1cyArIGNpcmNsZTIucmFkaXVzKQoKIyBFamVtcGxvIGRlIHVzbwpjaXJjbGUxID0gQ2lyY2xlKDAsIDAsIDUpCmNpcmNsZTIgPSBDaXJjbGUoNywgMCwgNSkKcHJpbnQoY2hlY2tfY29sbGlzaW9uKGNpcmNsZTEsIGNpcmNsZTIpKSAgIyBEZWJlcsOtYSBpbXByaW1pciBUcnVl"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import math

class Circle:
    def __init__(self, x, y, radius):
        self.x = x
        self.y = y
        self.radius = radius

def check_collision(circle1, circle2):
    distance = math.sqrt((circle1.x - circle2.x) ** 2 + (circle1.y - circle2.y) ** 2)
    return distance &lt; (circle1.radius + circle2.radius)

# Ejemplo de uso
circle1 = Circle(0, 0, 5)
circle2 = Circle(7, 0, 5)
print(check_collision(circle1, circle2))  # Deber&iacute;a imprimir True</pre></div><div class='content'></div><h1>Colisiones OBB (Oriented Bounding Box)</h1>
<div class='content'><p>Las colisiones OBB son más complejas que las AABB ya que las cajas pueden estar orientadas en cualquier dirección. Esto permite una detección de colisiones más precisa para objetos que no están alineados con los ejes.</p>
<ul>
<li>
<p><strong>Características</strong>:</p>
<ul>
<li>Las cajas pueden estar orientadas en cualquier dirección.</li>
<li>Más preciso pero también más costoso computacionalmente.</li>
<li>Ideal para objetos que no son rectangulares o cúbicos.</li>
</ul>
</li>
<li>
<p><strong>Ejemplo de Código</strong>:</p>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("IyBFc3RlIGVzIHVuIGVqZW1wbG8gc2ltcGxpZmljYWRvIHkgbm8gaW5jbHV5ZSB0b2RvcyBsb3MgY8OhbGN1bG9zIG5lY2VzYXJpb3MgcGFyYSBPQkIKY2xhc3MgT0JCOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGNlbnRlciwgaGFsZl9leHRlbnRzLCByb3RhdGlvbik6CiAgICAgICAgc2VsZi5jZW50ZXIgPSBjZW50ZXIKICAgICAgICBzZWxmLmhhbGZfZXh0ZW50cyA9IGhhbGZfZXh0ZW50cwogICAgICAgIHNlbGYucm90YXRpb24gPSByb3RhdGlvbgoKZGVmIGNoZWNrX2NvbGxpc2lvbihvYmIxLCBvYmIyKToKICAgICMgSW1wbGVtZW50YWNpw7NuIHNpbXBsaWZpY2FkYQogICAgcGFzcwoKIyBFamVtcGxvIGRlIHVzbwpvYmIxID0gT0JCKCgwLCAwKSwgKDUsIDUpLCAwKQpvYmIyID0gT0JCKCg3LCAwKSwgKDUsIDUpLCAwKQpwcmludChjaGVja19jb2xsaXNpb24ob2JiMSwgb2JiMikpICAjIEltcGxlbWVudGFjacOzbiBwZW5kaWVudGU="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'># Este es un ejemplo simplificado y no incluye todos los c&aacute;lculos necesarios para OBB
class OBB:
    def __init__(self, center, half_extents, rotation):
        self.center = center
        self.half_extents = half_extents
        self.rotation = rotation

def check_collision(obb1, obb2):
    # Implementaci&oacute;n simplificada
    pass

# Ejemplo de uso
obb1 = OBB((0, 0), (5, 5), 0)
obb2 = OBB((7, 0), (5, 5), 0)
print(check_collision(obb1, obb2))  # Implementaci&oacute;n pendiente</pre></div><div class='content'></div><h1>Colisiones de Polígonos</h1>
<div class='content'><p>Las colisiones de polígonos permiten una detección de colisiones muy precisa para objetos de formas complejas. Este método utiliza algoritmos como el Separating Axis Theorem (SAT).</p>
<ul>
<li>
<p><strong>Características</strong>:</p>
<ul>
<li>Muy preciso para formas complejas.</li>
<li>Computacionalmente costoso.</li>
<li>Requiere algoritmos avanzados como SAT.</li>
</ul>
</li>
<li>
<p><strong>Ejemplo de Código</strong>:</p>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("IyBJbXBsZW1lbnRhY2nDs24gc2ltcGxpZmljYWRhIGRlbCBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbSAoU0FUKQpjbGFzcyBQb2x5Z29uOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHZlcnRpY2VzKToKICAgICAgICBzZWxmLnZlcnRpY2VzID0gdmVydGljZXMKCmRlZiBjaGVja19jb2xsaXNpb24ocG9seWdvbjEsIHBvbHlnb24yKToKICAgICMgSW1wbGVtZW50YWNpw7NuIGRlbCBTQVQKICAgIHBhc3MKCiMgRWplbXBsbyBkZSB1c28KcG9seWdvbjEgPSBQb2x5Z29uKFsoMCwgMCksICg1LCAwKSwgKDUsIDUpLCAoMCwgNSldKQpwb2x5Z29uMiA9IFBvbHlnb24oWyg3LCAwKSwgKDEyLCAwKSwgKDEyLCA1KSwgKDcsIDUpXSkKcHJpbnQoY2hlY2tfY29sbGlzaW9uKHBvbHlnb24xLCBwb2x5Z29uMikpICAjIEltcGxlbWVudGFjacOzbiBwZW5kaWVudGU="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'># Implementaci&oacute;n simplificada del Separating Axis Theorem (SAT)
class Polygon:
    def __init__(self, vertices):
        self.vertices = vertices

def check_collision(polygon1, polygon2):
    # Implementaci&oacute;n del SAT
    pass

# Ejemplo de uso
polygon1 = Polygon([(0, 0), (5, 0), (5, 5), (0, 5)])
polygon2 = Polygon([(7, 0), (12, 0), (12, 5), (7, 5)])
print(check_collision(polygon1, polygon2))  # Implementaci&oacute;n pendiente</pre></div><div class='content'></div><h1>Conclusión</h1>
<div class='content'><p>La elección del tipo de colisión depende de la forma y el comportamiento de los objetos en tu videojuego. Las colisiones AABB y circulares son fáciles de implementar y eficientes, mientras que las colisiones OBB y de polígonos ofrecen mayor precisión a costa de una mayor complejidad computacional. Entender estos conceptos te permitirá crear interacciones más realistas y optimizadas en tus videojuegos.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
    <a href="cookies">Més informació</a>
</div>	

	</div>    
</body>
</html>
