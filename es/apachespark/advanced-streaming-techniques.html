<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy<br> y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<b id="lit_lang_es">Castellano</b>
				|
				<a href="https://campusempresa.cat/apachespark/advanced-streaming-techniques" id="lnk_lang_ca" data-lang="ca">Català</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="objective">El Proyecto</a>
				<a href="about">Sobre nosotros</a>
				<a href="contribute">Contribuir</a>
				<a href="donate">Donaciones</a>
				<a href="licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introducción</h1>
<div class='content'><p>En esta sección, profundizaremos en técnicas avanzadas de streaming en Apache Spark. Esto se basará en el conocimiento fundamental de Spark Streaming y Structured Streaming, e introducirá conceptos y optimizaciones más complejas.</p>
</div><h1>Conceptos Clave</h1>
<div class='content'><ul>
<li><strong>Procesamiento de Stream con Estado</strong>: Gestión de información de estado a través de lotes de streaming.</li>
<li><strong>Operaciones de Ventana</strong>: Agregación de datos sobre ventanas deslizantes o de tumbling.</li>
<li><strong>Watermarking</strong>: Manejo de llegadas tardías de datos.</li>
<li><strong>Operaciones de Join</strong>: Unión de datos de streaming con datos estáticos u otros datos de streaming.</li>
<li><strong>Tolerancia a Fallos</strong>: Asegurar la consistencia de los datos y la recuperación en caso de fallos.</li>
<li><strong>Ajuste de Rendimiento</strong>: Optimización de aplicaciones de streaming para un mejor rendimiento.</li>
</ul>
</div><h1>Procesamiento de Stream con Estado</h1>
<div class='content'><p>El procesamiento de stream con estado te permite mantener y actualizar información de estado a través de lotes de datos de streaming.</p>
</div><h2>Ejemplo: Conteo de Palabras con Procesamiento de Estado</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZnJvbSBweXNwYXJrLnNxbCBpbXBvcnQgU3BhcmtTZXNzaW9uCmZyb20gcHlzcGFyay5zcWwuZnVuY3Rpb25zIGltcG9ydCBleHBsb2RlLCBzcGxpdAoKc3BhcmsgPSBTcGFya1Nlc3Npb24uYnVpbGRlci5hcHBOYW1lKCJTdGF0ZWZ1bFdvcmRDb3VudCIpLmdldE9yQ3JlYXRlKCkKCiMgRGVmaW5pciBlbCBlc3F1ZW1hIGRlIGxvcyBkYXRvcyBkZSBlbnRyYWRhCnNjaGVtYSA9ICJ2YWx1ZSBTVFJJTkciCgojIExlZXIgZGF0b3MgZGUgc3RyZWFtaW5nIGRlc2RlIHVuIHNvY2tldApsaW5lcyA9IHNwYXJrLnJlYWRTdHJlYW0uZm9ybWF0KCJzb2NrZXQiKS5vcHRpb24oImhvc3QiLCAibG9jYWxob3N0Iikub3B0aW9uKCJwb3J0IiwgOTk5OSkubG9hZCgpCgojIERpdmlkaXIgbGFzIGzDrW5lYXMgZW4gcGFsYWJyYXMKd29yZHMgPSBsaW5lcy5zZWxlY3QoZXhwbG9kZShzcGxpdChsaW5lcy52YWx1ZSwgIiAiKSkuYWxpYXMoIndvcmQiKSkKCiMgR2VuZXJhciBjb250ZW8gZGUgcGFsYWJyYXMgZW4gZWplY3VjacOzbgp3b3JkQ291bnRzID0gd29yZHMuZ3JvdXBCeSgid29yZCIpLmNvdW50KCkKCiMgSW5pY2lhciBsYSBjb25zdWx0YSBxdWUgaW1wcmltZSBsb3MgY29udGVvcyBlbiBlamVjdWNpw7NuIGVuIGxhIGNvbnNvbGEKcXVlcnkgPSB3b3JkQ291bnRzLndyaXRlU3RyZWFtLm91dHB1dE1vZGUoImNvbXBsZXRlIikuZm9ybWF0KCJjb25zb2xlIikuc3RhcnQoKQoKcXVlcnkuYXdhaXRUZXJtaW5hdGlvbigp"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>from pyspark.sql import SparkSession
from pyspark.sql.functions import explode, split

spark = SparkSession.builder.appName(&quot;StatefulWordCount&quot;).getOrCreate()

# Definir el esquema de los datos de entrada
schema = &quot;value STRING&quot;

# Leer datos de streaming desde un socket
lines = spark.readStream.format(&quot;socket&quot;).option(&quot;host&quot;, &quot;localhost&quot;).option(&quot;port&quot;, 9999).load()

# Dividir las l&iacute;neas en palabras
words = lines.select(explode(split(lines.value, &quot; &quot;)).alias(&quot;word&quot;))

# Generar conteo de palabras en ejecuci&oacute;n
wordCounts = words.groupBy(&quot;word&quot;).count()

# Iniciar la consulta que imprime los conteos en ejecuci&oacute;n en la consola
query = wordCounts.writeStream.outputMode(&quot;complete&quot;).format(&quot;console&quot;).start()

query.awaitTermination()</pre></div><div class='content'><p>En este ejemplo, el conteo de palabras se mantiene a través de los lotes, demostrando el procesamiento con estado.</p>
</div><h1>Operaciones de Ventana</h1>
<div class='content'><p>Las operaciones de ventana te permiten realizar agregaciones sobre una ventana de tiempo especificada.</p>
</div><h2>Ejemplo: Conteo de Palabras con Ventana</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZnJvbSBweXNwYXJrLnNxbC5mdW5jdGlvbnMgaW1wb3J0IHdpbmRvdwoKd2luZG93ZWRDb3VudHMgPSB3b3Jkcy5ncm91cEJ5KHdpbmRvdyh3b3Jkcy50aW1lc3RhbXAsICIxMCBtaW51dGVzIiksIHdvcmRzLndvcmQpLmNvdW50KCkKCnF1ZXJ5ID0gd2luZG93ZWRDb3VudHMud3JpdGVTdHJlYW0ub3V0cHV0TW9kZSgiY29tcGxldGUiKS5mb3JtYXQoImNvbnNvbGUiKS5zdGFydCgpCgpxdWVyeS5hd2FpdFRlcm1pbmF0aW9uKCk="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>from pyspark.sql.functions import window

windowedCounts = words.groupBy(window(words.timestamp, &quot;10 minutes&quot;), words.word).count()

query = windowedCounts.writeStream.outputMode(&quot;complete&quot;).format(&quot;console&quot;).start()

query.awaitTermination()</pre></div><div class='content'><p>Este ejemplo muestra cómo contar palabras sobre una ventana deslizante de 10 minutos.</p>
</div><h1>Watermarking</h1>
<div class='content'><p>El watermarking ayuda a gestionar datos tardíos especificando cuán tarde pueden llegar los datos antes de ser ignorados.</p>
</div><h2>Ejemplo: Usando Watermarks</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("d2luZG93ZWRDb3VudHNXaXRoV2F0ZXJtYXJrID0gd29yZHMud2l0aFdhdGVybWFyaygidGltZXN0YW1wIiwgIjEwIG1pbnV0ZXMiKSBcCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdyb3VwQnkod2luZG93KHdvcmRzLnRpbWVzdGFtcCwgIjEwIG1pbnV0ZXMiKSwgd29yZHMud29yZCkgXAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb3VudCgpCgpxdWVyeSA9IHdpbmRvd2VkQ291bnRzV2l0aFdhdGVybWFyay53cml0ZVN0cmVhbS5vdXRwdXRNb2RlKCJhcHBlbmQiKS5mb3JtYXQoImNvbnNvbGUiKS5zdGFydCgpCgpxdWVyeS5hd2FpdFRlcm1pbmF0aW9uKCk="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>windowedCountsWithWatermark = words.withWatermark(&quot;timestamp&quot;, &quot;10 minutes&quot;) \
                                   .groupBy(window(words.timestamp, &quot;10 minutes&quot;), words.word) \
                                   .count()

query = windowedCountsWithWatermark.writeStream.outputMode(&quot;append&quot;).format(&quot;console&quot;).start()

query.awaitTermination()</pre></div><div class='content'><p>Aquí, los datos más antiguos que 10 minutos serán ignorados, asegurando un procesamiento oportuno.</p>
</div><h1>Operaciones de Join</h1>
<div class='content'><p>Unir datos de streaming con datos estáticos u otros datos de streaming puede ser complejo pero poderoso.</p>
</div><h2>Ejemplo: Join Stream-Static</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("IyBEYXRhRnJhbWUgRXN0w6F0aWNvCnN0YXRpY0RhdGEgPSBzcGFyay5yZWFkLmZvcm1hdCgiY3N2Iikub3B0aW9uKCJoZWFkZXIiLCAidHJ1ZSIpLmxvYWQoInBhdGgvdG8vc3RhdGljL2RhdGEuY3N2IikKCiMgSm9pbiBTdHJlYW0tU3RhdGljCmpvaW5lZERhdGEgPSB3b3Jkcy5qb2luKHN0YXRpY0RhdGEsIHdvcmRzLndvcmQgPT0gc3RhdGljRGF0YS53b3JkKQoKcXVlcnkgPSBqb2luZWREYXRhLndyaXRlU3RyZWFtLm91dHB1dE1vZGUoImFwcGVuZCIpLmZvcm1hdCgiY29uc29sZSIpLnN0YXJ0KCkKCnF1ZXJ5LmF3YWl0VGVybWluYXRpb24oKQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'># DataFrame Est&aacute;tico
staticData = spark.read.format(&quot;csv&quot;).option(&quot;header&quot;, &quot;true&quot;).load(&quot;path/to/static/data.csv&quot;)

# Join Stream-Static
joinedData = words.join(staticData, words.word == staticData.word)

query = joinedData.writeStream.outputMode(&quot;append&quot;).format(&quot;console&quot;).start()

query.awaitTermination()</pre></div><div class='content'><p>Este ejemplo demuestra la unión de un stream con un conjunto de datos estático.</p>
</div><h1>Tolerancia a Fallos</h1>
<div class='content'><p>Asegurar la tolerancia a fallos es crucial para aplicaciones de streaming fiables.</p>
</div><h2>Técnicas:</h2>
<div class='content'><ul>
<li><strong>Checkpointing</strong>: Guardar el estado del stream para recuperarse de fallos.</li>
<li><strong>Write-Ahead Logs (WAL)</strong>: Registrar datos antes de procesarlos para asegurar que no haya pérdida de datos.</li>
</ul>
</div><h1>Ajuste de Rendimiento</h1>
<div class='content'><p>Optimizar aplicaciones de streaming puede mejorar significativamente el rendimiento.</p>
</div><h2>Técnicas:</h2>
<div class='content'><ul>
<li><strong>Ajuste del Tamaño de Lote</strong>: Ajustar el tamaño de cada lote para un procesamiento óptimo.</li>
<li><strong>Asignación de Recursos</strong>: Asignar recursos suficientes (CPU, memoria) a la aplicación de streaming.</li>
<li><strong>Particionamiento de Datos</strong>: Asegurar que los datos estén uniformemente particionados para evitar cuellos de botella.</li>
</ul>
</div><h1>Conclusión</h1>
<div class='content'><p>Las técnicas avanzadas de streaming en Apache Spark permiten un procesamiento de stream robusto, eficiente y escalable. Al dominar el procesamiento con estado, las operaciones de ventana, el watermarking, las operaciones de join, la tolerancia a fallos y el ajuste de rendimiento, puedes construir aplicaciones de streaming sofisticadas que manejen datos en tiempo real de manera efectiva.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
       <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
       <a href="cookies">Més informació</a>
   </div>	
	</div>    
</body>
</html>
