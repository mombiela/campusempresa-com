<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestión de Memoria en DirectX</title>

    <link rel="alternate" href="https://campusempresa.com/es/direct_x/memory-management" hreflang="es" />
    <link rel="alternate" href="https://campusempresa.com/es/direct_x/memory-management" hreflang="x-default" />
	<link rel="alternate" href="https://campusempresa.com/ca/direct_x/memory-management" hreflang="ca" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/es/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<b id="lit_lang_es" class="px-2">ES</b>
				|
				<a href="/ca/direct_x/memory-management" id="lnk_lang_ca" data-lang="ca" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/es/objective">El Proyecto</a>
				<a href="/es/about">Sobre nosotros</a>
				<a href="/es/contribute">Contribuir</a>
				<a href="/es/donate">Donaciones</a>
				<a href="/es/licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='row navigation'>
	<div class='col-4'>
					<a href='performance-optimization'>&#x25C4;Optimización de Rendimiento</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Gestión de Memoria en DirectX</a>
	</div>
	<div class='col-4 text-end'>
					<a href='debugging-and-profiling'>Depuración y Perfilado &#x25BA;</a>
			</div>
</div>
<div class='content'><p>La gestión de memoria es un aspecto crítico en el desarrollo de aplicaciones eficientes y efectivas utilizando DirectX. Este tema te guiará desde los conceptos básicos de la gestión de memoria hasta técnicas avanzadas, asegurando que tengas una comprensión sólida de cómo manejar la memoria en aplicaciones DirectX.</p>
</div><h1>Introducción a la Gestión de Memoria</h1>
<div class='content'><p>La gestión de memoria en DirectX implica la asignación, uso y liberación de recursos de memoria necesarios para renderizar gráficos. Una gestión adecuada de la memoria asegura que tu aplicación funcione sin problemas y de manera eficiente, sin quedarse sin memoria o causar fugas de memoria.</p>
</div><h2>Conceptos Clave</h2>
<div class='content'><ul>
<li><strong>Memoria Heap</strong>: Memoria asignada dinámicamente durante el tiempo de ejecución.</li>
<li><strong>Memoria Stack</strong>: Memoria asignada para la gestión de llamadas a funciones.</li>
<li><strong>VRAM (Memoria de Video)</strong>: Memoria en la GPU utilizada para almacenar texturas, búferes y otros datos gráficos.</li>
<li><strong>Vida Útil del Recurso</strong>: El período durante el cual un recurso está asignado y en uso.</li>
<li><strong>Fugas de Memoria</strong>: Ocurren cuando la memoria que ya no se necesita no se libera adecuadamente.</li>
</ul>
</div><h1>Técnicas Básicas de Gestión de Memoria</h1>
<div class='content'></div><h2>Asignación y Liberación de Recursos</h2>
<div class='content'><p>En DirectX, recursos como texturas, búferes y shaders deben ser asignados y liberados adecuadamente para gestionar la memoria de manera eficiente.</p>
<h4>Ejemplo: Creación y Liberación de un Búfer</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRGVmaW5pciBsYSBkZXNjcmlwY2nDs24gZGVsIGLDumZlcgpEM0QxMV9CVUZGRVJfREVTQyBidWZmZXJEZXNjID0ge307CmJ1ZmZlckRlc2MuVXNhZ2UgPSBEM0QxMV9VU0FHRV9ERUZBVUxUOwpidWZmZXJEZXNjLkJ5dGVXaWR0aCA9IHNpemVvZihWZXJ0ZXgpICogdmVydGV4Q291bnQ7CmJ1ZmZlckRlc2MuQmluZEZsYWdzID0gRDNEMTFfQklORF9WRVJURVhfQlVGRkVSOwpidWZmZXJEZXNjLkNQVUFjY2Vzc0ZsYWdzID0gMDsKCi8vIERlZmluaXIgbG9zIGRhdG9zIGluaWNpYWxlcwpEM0QxMV9TVUJSRVNPVVJDRV9EQVRBIGluaXREYXRhID0ge307CmluaXREYXRhLnBTeXNNZW0gPSB2ZXJ0aWNlczsKCi8vIENyZWFyIGVsIGLDumZlcgpJRDNEMTFCdWZmZXIqIHZlcnRleEJ1ZmZlciA9IG51bGxwdHI7CkhSRVNVTFQgaHIgPSBkZXZpY2UtPkNyZWF0ZUJ1ZmZlcigmYnVmZmVyRGVzYywgJmluaXREYXRhLCAmdmVydGV4QnVmZmVyKTsKaWYgKEZBSUxFRChocikpIHsKICAgIC8vIE1hbmVqYXIgZXJyb3IKfQoKLy8gVXNhciBlbCBiw7pmZXIuLi4KCi8vIExpYmVyYXIgZWwgYsO6ZmVyIGN1YW5kbyBzZSB0ZXJtaW5lCmlmICh2ZXJ0ZXhCdWZmZXIpIHsKICAgIHZlcnRleEJ1ZmZlci0+UmVsZWFzZSgpOwogICAgdmVydGV4QnVmZmVyID0gbnVsbHB0cjsKfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Definir la descripci&oacute;n del b&uacute;fer
D3D11_BUFFER_DESC bufferDesc = {};
bufferDesc.Usage = D3D11_USAGE_DEFAULT;
bufferDesc.ByteWidth = sizeof(Vertex) * vertexCount;
bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
bufferDesc.CPUAccessFlags = 0;

// Definir los datos iniciales
D3D11_SUBRESOURCE_DATA initData = {};
initData.pSysMem = vertices;

// Crear el b&uacute;fer
ID3D11Buffer* vertexBuffer = nullptr;
HRESULT hr = device-&gt;CreateBuffer(&amp;bufferDesc, &amp;initData, &amp;vertexBuffer);
if (FAILED(hr)) {
    // Manejar error
}

// Usar el b&uacute;fer...

// Liberar el b&uacute;fer cuando se termine
if (vertexBuffer) {
    vertexBuffer-&gt;Release();
    vertexBuffer = nullptr;
}</pre></div><div class='content'><ul>
<li><strong>Explicación</strong>: Este fragmento de código demuestra cómo crear un búfer de vértices y liberarlo cuando ya no se necesita. Liberar adecuadamente los recursos es crucial para evitar fugas de memoria.</li>
</ul>
</div><h2>Gestión de la Vida Útil del Recurso</h2>
<div class='content'><p>Entender la vida útil de los recursos es esencial para una gestión eficiente de la memoria. Los recursos deben ser creados cuando se necesitan y liberados tan pronto como ya no sean requeridos.</p>
</div><h1>Técnicas Intermedias de Gestión de Memoria</h1>
<div class='content'></div><h2>Uso de Smart Pointers</h2>
<div class='content'><p>Los smart pointers en C++ pueden ayudar a gestionar automáticamente la vida útil de los recursos, reduciendo el riesgo de fugas de memoria.</p>
<h4>Ejemplo: Uso de ComPtr para Recursos DirectX</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPHdybC9jbGllbnQuaD4KdXNpbmcgTWljcm9zb2Z0OjpXUkw6OkNvbVB0cjsKCi8vIERlZmluaXIgdW4gc21hcnQgcG9pbnRlciBwYXJhIHVuIHJlY3Vyc28gRGlyZWN0WApDb21QdHI8SUQzRDExQnVmZmVyPiB2ZXJ0ZXhCdWZmZXI7CgovLyBDcmVhciBlbCBiw7pmZXIKSFJFU1VMVCBociA9IGRldmljZS0+Q3JlYXRlQnVmZmVyKCZidWZmZXJEZXNjLCAmaW5pdERhdGEsIHZlcnRleEJ1ZmZlci5HZXRBZGRyZXNzT2YoKSk7CmlmIChGQUlMRUQoaHIpKSB7CiAgICAvLyBNYW5lamFyIGVycm9yCn0KCi8vIFVzYXIgZWwgYsO6ZmVyLi4uCgovLyBObyBlcyBuZWNlc2FyaW8gbGliZXJhciBtYW51YWxtZW50ZSBlbCBiw7pmZXIsIENvbVB0ciBsbyBtYW5lamFyw6E="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;wrl/client.h&gt;
using Microsoft::WRL::ComPtr;

// Definir un smart pointer para un recurso DirectX
ComPtr&lt;ID3D11Buffer&gt; vertexBuffer;

// Crear el b&uacute;fer
HRESULT hr = device-&gt;CreateBuffer(&amp;bufferDesc, &amp;initData, vertexBuffer.GetAddressOf());
if (FAILED(hr)) {
    // Manejar error
}

// Usar el b&uacute;fer...

// No es necesario liberar manualmente el b&uacute;fer, ComPtr lo manejar&aacute;</pre></div><div class='content'><ul>
<li><strong>Explicación</strong>: <code>ComPtr</code> es un smart pointer proporcionado por la Windows Runtime Library (WRL) que libera automáticamente el recurso cuando sale del ámbito.</li>
</ul>
</div><h2>Actualización Eficiente de Recursos</h2>
<div class='content'><p>Actualizar recursos de manera eficiente puede ayudar a gestionar el uso de memoria y mejorar el rendimiento.</p>
<h4>Ejemplo: Actualización de un Búfer</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gTWFwZWFyIGVsIGLDumZlciBwYXJhIGFjdHVhbGl6YXIgc3UgY29udGVuaWRvCkQzRDExX01BUFBFRF9TVUJSRVNPVVJDRSBtYXBwZWRSZXNvdXJjZTsKaHIgPSBjb250ZXh0LT5NYXAodmVydGV4QnVmZmVyLkdldCgpLCAwLCBEM0QxMV9NQVBfV1JJVEVfRElTQ0FSRCwgMCwgJm1hcHBlZFJlc291cmNlKTsKaWYgKFNVQ0NFRURFRChocikpIHsKICAgIC8vIENvcGlhciBudWV2b3MgZGF0b3MgZW4gZWwgYsO6ZmVyCiAgICBtZW1jcHkobWFwcGVkUmVzb3VyY2UucERhdGEsIG5ld1ZlcnRpY2VzLCBzaXplb2YoVmVydGV4KSAqIHZlcnRleENvdW50KTsKICAgIGNvbnRleHQtPlVubWFwKHZlcnRleEJ1ZmZlci5HZXQoKSwgMCk7Cn0="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Mapear el b&uacute;fer para actualizar su contenido
D3D11_MAPPED_SUBRESOURCE mappedResource;
hr = context-&gt;Map(vertexBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource);
if (SUCCEEDED(hr)) {
    // Copiar nuevos datos en el b&uacute;fer
    memcpy(mappedResource.pData, newVertices, sizeof(Vertex) * vertexCount);
    context-&gt;Unmap(vertexBuffer.Get(), 0);
}</pre></div><div class='content'><ul>
<li><strong>Explicación</strong>: Este ejemplo muestra cómo mapear un búfer, actualizar su contenido y desmapearlo. Usar <code>D3D11_MAP_WRITE_DISCARD</code> asegura que la GPU pueda manejar la actualización de manera eficiente.</li>
</ul>
</div><h1>Técnicas Avanzadas de Gestión de Memoria</h1>
<div class='content'></div><h2>Pools de Memoria</h2>
<div class='content'><p>Los pools de memoria pueden ser utilizados para gestionar la memoria de manera más eficiente al asignar un gran bloque de memoria y subasignar trozos más pequeños de él.</p>
<h4>Ejemplo: Implementación de un Pool de Memoria Simple</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Y2xhc3MgTWVtb3J5UG9vbCB7CnB1YmxpYzoKICAgIE1lbW9yeVBvb2woc2l6ZV90IHNpemUpIHsKICAgICAgICBwb29sID0gbWFsbG9jKHNpemUpOwogICAgICAgIHBvb2xTaXplID0gc2l6ZTsKICAgICAgICB1c2VkID0gMDsKICAgIH0KCiAgICB+TWVtb3J5UG9vbCgpIHsKICAgICAgICBmcmVlKHBvb2wpOwogICAgfQoKICAgIHZvaWQqIEFsbG9jYXRlKHNpemVfdCBzaXplKSB7CiAgICAgICAgaWYgKHVzZWQgKyBzaXplID4gcG9vbFNpemUpIHsKICAgICAgICAgICAgcmV0dXJuIG51bGxwdHI7IC8vIE5vIGhheSBzdWZpY2llbnRlIG1lbW9yaWEKICAgICAgICB9CiAgICAgICAgdm9pZCogcHRyID0gc3RhdGljX2Nhc3Q8Y2hhcio+KHBvb2wpICsgdXNlZDsKICAgICAgICB1c2VkICs9IHNpemU7CiAgICAgICAgcmV0dXJuIHB0cjsKICAgIH0KCiAgICB2b2lkIFJlc2V0KCkgewogICAgICAgIHVzZWQgPSAwOwogICAgfQoKcHJpdmF0ZToKICAgIHZvaWQqIHBvb2w7CiAgICBzaXplX3QgcG9vbFNpemU7CiAgICBzaXplX3QgdXNlZDsKfTsKCi8vIFVzbwpNZW1vcnlQb29sIHBvb2woMTAyNCAqIDEwMjQpOyAvLyBQb29sIGRlIDEgTUIKdm9pZCogbWVtb3J5ID0gcG9vbC5BbGxvY2F0ZSgyNTYpOyAvLyBBc2lnbmFyIDI1NiBieXRlcw=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>class MemoryPool {
public:
    MemoryPool(size_t size) {
        pool = malloc(size);
        poolSize = size;
        used = 0;
    }

    ~MemoryPool() {
        free(pool);
    }

    void* Allocate(size_t size) {
        if (used + size &gt; poolSize) {
            return nullptr; // No hay suficiente memoria
        }
        void* ptr = static_cast&lt;char*&gt;(pool) + used;
        used += size;
        return ptr;
    }

    void Reset() {
        used = 0;
    }

private:
    void* pool;
    size_t poolSize;
    size_t used;
};

// Uso
MemoryPool pool(1024 * 1024); // Pool de 1 MB
void* memory = pool.Allocate(256); // Asignar 256 bytes</pre></div><div class='content'><ul>
<li><strong>Explicación</strong>: Este código demuestra una implementación simple de un pool de memoria. Los pools de memoria pueden ayudar a reducir la fragmentación y mejorar el rendimiento de la asignación.</li>
</ul>
</div><h2>Manejo de Texturas y Búferes Grandes</h2>
<div class='content'><p>Gestionar texturas y búferes grandes de manera eficiente es crucial para aplicaciones de alto rendimiento.</p>
<h4>Ejemplo: Uso de Arrays de Texturas</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRGVmaW5pciBsYSBkZXNjcmlwY2nDs24gZGVsIGFycmF5IGRlIHRleHR1cmFzCkQzRDExX1RFWFRVUkUyRF9ERVNDIHRleHR1cmVEZXNjID0ge307CnRleHR1cmVEZXNjLldpZHRoID0gdGV4dHVyZVdpZHRoOwp0ZXh0dXJlRGVzYy5IZWlnaHQgPSB0ZXh0dXJlSGVpZ2h0Owp0ZXh0dXJlRGVzYy5NaXBMZXZlbHMgPSAxOwp0ZXh0dXJlRGVzYy5BcnJheVNpemUgPSB0ZXh0dXJlQXJyYXlTaXplOwp0ZXh0dXJlRGVzYy5Gb3JtYXQgPSBEWEdJX0ZPUk1BVF9SOEc4QjhBOF9VTk9STTsKdGV4dHVyZURlc2MuVXNhZ2UgPSBEM0QxMV9VU0FHRV9ERUZBVUxUOwp0ZXh0dXJlRGVzYy5CaW5kRmxhZ3MgPSBEM0QxMV9CSU5EX1NIQURFUl9SRVNPVVJDRTsKdGV4dHVyZURlc2MuU2FtcGxlRGVzYy5Db3VudCA9IDE7CgovLyBDcmVhciBlbCBhcnJheSBkZSB0ZXh0dXJhcwpJRDNEMTFUZXh0dXJlMkQqIHRleHR1cmVBcnJheSA9IG51bGxwdHI7CmhyID0gZGV2aWNlLT5DcmVhdGVUZXh0dXJlMkQoJnRleHR1cmVEZXNjLCBudWxscHRyLCAmdGV4dHVyZUFycmF5KTsKaWYgKEZBSUxFRChocikpIHsKICAgIC8vIE1hbmVqYXIgZXJyb3IKfQoKLy8gVXNhciBlbCBhcnJheSBkZSB0ZXh0dXJhcy4uLgoKLy8gTGliZXJhciBlbCBhcnJheSBkZSB0ZXh0dXJhcyBjdWFuZG8gc2UgdGVybWluZQppZiAodGV4dHVyZUFycmF5KSB7CiAgICB0ZXh0dXJlQXJyYXktPlJlbGVhc2UoKTsKICAgIHRleHR1cmVBcnJheSA9IG51bGxwdHI7Cn0="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Definir la descripci&oacute;n del array de texturas
D3D11_TEXTURE2D_DESC textureDesc = {};
textureDesc.Width = textureWidth;
textureDesc.Height = textureHeight;
textureDesc.MipLevels = 1;
textureDesc.ArraySize = textureArraySize;
textureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
textureDesc.Usage = D3D11_USAGE_DEFAULT;
textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
textureDesc.SampleDesc.Count = 1;

// Crear el array de texturas
ID3D11Texture2D* textureArray = nullptr;
hr = device-&gt;CreateTexture2D(&amp;textureDesc, nullptr, &amp;textureArray);
if (FAILED(hr)) {
    // Manejar error
}

// Usar el array de texturas...

// Liberar el array de texturas cuando se termine
if (textureArray) {
    textureArray-&gt;Release();
    textureArray = nullptr;
}</pre></div><div class='content'><ul>
<li><strong>Explicación</strong>: Este ejemplo muestra cómo crear un array de texturas, que puede ser más eficiente que usar múltiples texturas individuales.</li>
</ul>
</div><h1>Resumen</h1>
<div class='content'><p>La gestión de memoria en DirectX es una habilidad fundamental que implica entender cómo asignar, usar y liberar recursos de manera eficiente. Desde técnicas básicas como la creación y liberación de búferes hasta métodos avanzados como el uso de pools de memoria y el manejo de texturas grandes, dominar la gestión de memoria te ayudará a desarrollar aplicaciones DirectX de alto rendimiento.</p>
<p>Siguiendo las mejores prácticas y aprovechando herramientas como smart pointers y actualizaciones eficientes de recursos, puedes asegurar que tus aplicaciones funcionen sin problemas y evitar trampas comunes como fugas de memoria y fragmentación.</p>
</div><div class='row navigation'>
	<div class='col-4'>
					<a href='performance-optimization'>&#x25C4;Optimización de Rendimiento</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Gestión de Memoria en DirectX</a>
	</div>
	<div class='col-4 text-end'>
					<a href='debugging-and-profiling'>Depuración y Perfilado &#x25BA;</a>
			</div>
</div>
</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
    <a href="/es/cookies">Més informació</a>
</div>	

	</div>    
</body>
</html>
