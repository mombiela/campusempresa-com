<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy<br> y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<b id="lit_lang_es">Castellano</b>
				|
				<a href="https://campusempresa.cat/c/trees" id="lnk_lang_ca" data-lang="ca">Català</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="objective">El Proyecto</a>
				<a href="about">Sobre nosotros</a>
				<a href="contribute">Contribuir</a>
				<a href="donate">Donaciones</a>
				<a href="licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introducción a los Árboles</h1>
<div class='content'><p>Los árboles son una estructura de datos fundamental en la informática, utilizada para representar relaciones jerárquicas. Son particularmente útiles para organizar datos que tienen una jerarquía natural, como sistemas de archivos, estructuras organizativas y más.</p>
</div><h2>Conceptos Clave</h2>
<div class='content'><ul>
<li><strong>Nodo</strong>: La unidad básica de un árbol, que contiene datos y referencias a otros nodos.</li>
<li><strong>Raíz</strong>: El nodo más alto en un árbol.</li>
<li><strong>Hijo</strong>: Un nodo directamente conectado a otro nodo al alejarse de la raíz.</li>
<li><strong>Padre</strong>: La noción inversa de un hijo.</li>
<li><strong>Hoja</strong>: Un nodo sin hijos.</li>
<li><strong>Subárbol</strong>: Un árbol formado por un nodo y sus descendientes.</li>
<li><strong>Árbol Binario</strong>: Un árbol donde cada nodo tiene como máximo dos hijos.</li>
<li><strong>Árbol Binario de Búsqueda (BST)</strong>: Un árbol binario donde el hijo izquierdo contiene solo nodos con valores menores que el nodo padre, y el hijo derecho solo nodos con valores mayores que el nodo padre.</li>
</ul>
</div><h1>Estructura Básica del Árbol en C</h1>
<div class='content'></div><h2>Definiendo un Nodo</h2>
<div class='content'><p>En C, un nodo de árbol puede definirse usando una <code>struct</code>. Aquí hay un ejemplo de una estructura básica de nodo para un árbol binario:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KCi8vIERlZmluaXIgbGEgZXN0cnVjdHVyYSBwYXJhIHVuIG5vZG8gZGUgw6FyYm9sCnN0cnVjdCBOb2RlIHsKICAgIGludCBkYXRhOwogICAgc3RydWN0IE5vZGUqIGxlZnQ7CiAgICBzdHJ1Y3QgTm9kZSogcmlnaHQ7Cn07CgovLyBGdW5jacOzbiBwYXJhIGNyZWFyIHVuIG51ZXZvIG5vZG8Kc3RydWN0IE5vZGUqIGNyZWF0ZU5vZGUoaW50IGRhdGEpIHsKICAgIHN0cnVjdCBOb2RlKiBuZXdOb2RlID0gKHN0cnVjdCBOb2RlKiltYWxsb2Moc2l6ZW9mKHN0cnVjdCBOb2RlKSk7CiAgICBuZXdOb2RlLT5kYXRhID0gZGF0YTsKICAgIG5ld05vZGUtPmxlZnQgPSBOVUxMOwogICAgbmV3Tm9kZS0+cmlnaHQgPSBOVUxMOwogICAgcmV0dXJuIG5ld05vZGU7Cn0="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Definir la estructura para un nodo de &aacute;rbol
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Funci&oacute;n para crear un nuevo nodo
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode-&gt;data = data;
    newNode-&gt;left = NULL;
    newNode-&gt;right = NULL;
    return newNode;
}</pre></div><div class='content'></div><h2>Creando un Árbol Simple</h2>
<div class='content'><p>Vamos a crear un árbol binario simple con tres nodos:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW50IG1haW4oKSB7CiAgICAvLyBDcmVhciBlbCBub2RvIHJhw616CiAgICBzdHJ1Y3QgTm9kZSogcm9vdCA9IGNyZWF0ZU5vZGUoMSk7CiAgICAKICAgIC8vIENyZWFyIGhpam9zIGl6cXVpZXJkbyB5IGRlcmVjaG8KICAgIHJvb3QtPmxlZnQgPSBjcmVhdGVOb2RlKDIpOwogICAgcm9vdC0+cmlnaHQgPSBjcmVhdGVOb2RlKDMpOwogICAgCiAgICAvLyBJbXByaW1pciBsYSByYcOteiB5IHN1cyBoaWpvcwogICAgcHJpbnRmKCJSYcOtejogJWRcbiIsIHJvb3QtPmRhdGEpOwogICAgcHJpbnRmKCJIaWpvIEl6cXVpZXJkbzogJWRcbiIsIHJvb3QtPmxlZnQtPmRhdGEpOwogICAgcHJpbnRmKCJIaWpvIERlcmVjaG86ICVkXG4iLCByb290LT5yaWdodC0+ZGF0YSk7CiAgICAKICAgIHJldHVybiAwOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>int main() {
    // Crear el nodo ra&iacute;z
    struct Node* root = createNode(1);
    
    // Crear hijos izquierdo y derecho
    root-&gt;left = createNode(2);
    root-&gt;right = createNode(3);
    
    // Imprimir la ra&iacute;z y sus hijos
    printf(&quot;Ra&iacute;z: %d\n&quot;, root-&gt;data);
    printf(&quot;Hijo Izquierdo: %d\n&quot;, root-&gt;left-&gt;data);
    printf(&quot;Hijo Derecho: %d\n&quot;, root-&gt;right-&gt;data);
    
    return 0;
}</pre></div><div class='content'></div><h1>Árbol Binario de Búsqueda (BST)</h1>
<div class='content'></div><h2>Inserción en BST</h2>
<div class='content'><p>Insertar un nodo en un BST implica colocar el nuevo nodo en la posición correcta para mantener las propiedades del BST.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("c3RydWN0IE5vZGUqIGluc2VydChzdHJ1Y3QgTm9kZSogbm9kZSwgaW50IGRhdGEpIHsKICAgIC8vIFNpIGVsIMOhcmJvbCBlc3TDoSB2YWPDrW8sIGRldm9sdmVyIHVuIG51ZXZvIG5vZG8KICAgIGlmIChub2RlID09IE5VTEwpIHJldHVybiBjcmVhdGVOb2RlKGRhdGEpOwoKICAgIC8vIERlIGxvIGNvbnRyYXJpbywgcmVjb3JyZXIgZWwgw6FyYm9sCiAgICBpZiAoZGF0YSA8IG5vZGUtPmRhdGEpCiAgICAgICAgbm9kZS0+bGVmdCA9IGluc2VydChub2RlLT5sZWZ0LCBkYXRhKTsKICAgIGVsc2UgaWYgKGRhdGEgPiBub2RlLT5kYXRhKQogICAgICAgIG5vZGUtPnJpZ2h0ID0gaW5zZXJ0KG5vZGUtPnJpZ2h0LCBkYXRhKTsKCiAgICAvLyBEZXZvbHZlciBlbCBwdW50ZXJvIGRlbCBub2RvIChzaW4gY2FtYmlvcykKICAgIHJldHVybiBub2RlOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>struct Node* insert(struct Node* node, int data) {
    // Si el &aacute;rbol est&aacute; vac&iacute;o, devolver un nuevo nodo
    if (node == NULL) return createNode(data);

    // De lo contrario, recorrer el &aacute;rbol
    if (data &lt; node-&gt;data)
        node-&gt;left = insert(node-&gt;left, data);
    else if (data &gt; node-&gt;data)
        node-&gt;right = insert(node-&gt;right, data);

    // Devolver el puntero del nodo (sin cambios)
    return node;
}</pre></div><div class='content'></div><h2>Búsqueda en BST</h2>
<div class='content'><p>Buscar un valor en un BST implica comparar el valor objetivo con el valor del nodo actual y decidir si ir a la izquierda o a la derecha.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("c3RydWN0IE5vZGUqIHNlYXJjaChzdHJ1Y3QgTm9kZSogcm9vdCwgaW50IGRhdGEpIHsKICAgIC8vIENhc29zIEJhc2U6IGxhIHJhw616IGVzIG51bGEgbyBlbCBkYXRvIGVzdMOhIHByZXNlbnRlIGVuIGxhIHJhw616CiAgICBpZiAocm9vdCA9PSBOVUxMIHx8IHJvb3QtPmRhdGEgPT0gZGF0YSkKICAgICAgIHJldHVybiByb290OwogICAgCiAgICAvLyBFbCBkYXRvIGVzIG1heW9yIHF1ZSBlbCBkYXRvIGRlIGxhIHJhw616CiAgICBpZiAocm9vdC0+ZGF0YSA8IGRhdGEpCiAgICAgICByZXR1cm4gc2VhcmNoKHJvb3QtPnJpZ2h0LCBkYXRhKTsKCiAgICAvLyBFbCBkYXRvIGVzIG1lbm9yIHF1ZSBlbCBkYXRvIGRlIGxhIHJhw616CiAgICByZXR1cm4gc2VhcmNoKHJvb3QtPmxlZnQsIGRhdGEpOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>struct Node* search(struct Node* root, int data) {
    // Casos Base: la ra&iacute;z es nula o el dato est&aacute; presente en la ra&iacute;z
    if (root == NULL || root-&gt;data == data)
       return root;
    
    // El dato es mayor que el dato de la ra&iacute;z
    if (root-&gt;data &lt; data)
       return search(root-&gt;right, data);

    // El dato es menor que el dato de la ra&iacute;z
    return search(root-&gt;left, data);
}</pre></div><div class='content'></div><h1>Recorridos de Árbol</h1>
<div class='content'><p>El recorrido de un árbol se refiere al proceso de visitar todos los nodos en un árbol en un orden específico.</p>
</div><h2>Recorrido Inorden</h2>
<div class='content'><p>El recorrido inorden visita los nodos en el siguiente orden: subárbol izquierdo, raíz, subárbol derecho.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("dm9pZCBpbm9yZGVyVHJhdmVyc2FsKHN0cnVjdCBOb2RlKiByb290KSB7CiAgICBpZiAocm9vdCAhPSBOVUxMKSB7CiAgICAgICAgaW5vcmRlclRyYXZlcnNhbChyb290LT5sZWZ0KTsKICAgICAgICBwcmludGYoIiVkICIsIHJvb3QtPmRhdGEpOwogICAgICAgIGlub3JkZXJUcmF2ZXJzYWwocm9vdC0+cmlnaHQpOwogICAgfQp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>void inorderTraversal(struct Node* root) {
    if (root != NULL) {
        inorderTraversal(root-&gt;left);
        printf(&quot;%d &quot;, root-&gt;data);
        inorderTraversal(root-&gt;right);
    }
}</pre></div><div class='content'></div><h2>Recorrido Preorden</h2>
<div class='content'><p>El recorrido preorden visita los nodos en el siguiente orden: raíz, subárbol izquierdo, subárbol derecho.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("dm9pZCBwcmVvcmRlclRyYXZlcnNhbChzdHJ1Y3QgTm9kZSogcm9vdCkgewogICAgaWYgKHJvb3QgIT0gTlVMTCkgewogICAgICAgIHByaW50ZigiJWQgIiwgcm9vdC0+ZGF0YSk7CiAgICAgICAgcHJlb3JkZXJUcmF2ZXJzYWwocm9vdC0+bGVmdCk7CiAgICAgICAgcHJlb3JkZXJUcmF2ZXJzYWwocm9vdC0+cmlnaHQpOwogICAgfQp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>void preorderTraversal(struct Node* root) {
    if (root != NULL) {
        printf(&quot;%d &quot;, root-&gt;data);
        preorderTraversal(root-&gt;left);
        preorderTraversal(root-&gt;right);
    }
}</pre></div><div class='content'></div><h2>Recorrido Postorden</h2>
<div class='content'><p>El recorrido postorden visita los nodos en el siguiente orden: subárbol izquierdo, subárbol derecho, raíz.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("dm9pZCBwb3N0b3JkZXJUcmF2ZXJzYWwoc3RydWN0IE5vZGUqIHJvb3QpIHsKICAgIGlmIChyb290ICE9IE5VTEwpIHsKICAgICAgICBwb3N0b3JkZXJUcmF2ZXJzYWwocm9vdC0+bGVmdCk7CiAgICAgICAgcG9zdG9yZGVyVHJhdmVyc2FsKHJvb3QtPnJpZ2h0KTsKICAgICAgICBwcmludGYoIiVkICIsIHJvb3QtPmRhdGEpOwogICAgfQp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>void postorderTraversal(struct Node* root) {
    if (root != NULL) {
        postorderTraversal(root-&gt;left);
        postorderTraversal(root-&gt;right);
        printf(&quot;%d &quot;, root-&gt;data);
    }
}</pre></div><div class='content'></div><h1>Temas Avanzados</h1>
<div class='content'></div><h2>Balanceo de Árboles</h2>
<div class='content'><p>Balancear un árbol asegura que el árbol permanezca eficiente para operaciones como inserción, eliminación y búsqueda. Los árboles balanceados comunes incluyen los árboles AVL y los árboles Rojo-Negro.</p>
</div><h2>Árboles AVL</h2>
<div class='content'><p>Un árbol AVL es un árbol binario de búsqueda auto-balanceado donde la diferencia entre las alturas de los subárboles izquierdo y derecho no puede ser mayor que uno para todos los nodos.</p>
</div><h2>Árboles Rojo-Negro</h2>
<div class='content'><p>Un árbol Rojo-Negro es un tipo de árbol binario de búsqueda auto-balanceado donde cada nodo contiene un bit extra para denotar el color del nodo, ya sea rojo o negro.</p>
</div><h1>Conclusión</h1>
<div class='content'><p>Los árboles son una estructura de datos versátil y esencial en la informática. Comprender los conceptos básicos de las estructuras de árboles, los árboles binarios de búsqueda y los recorridos de árboles es crucial para resolver muchos problemas complejos de manera eficiente. A medida que avances, explorar árboles balanceados como los árboles AVL y Rojo-Negro mejorará aún más tu capacidad para gestionar datos jerárquicos de manera efectiva.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
       <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
       <a href="cookies">Més informació</a>
   </div>	
	</div>    
</body>
</html>
