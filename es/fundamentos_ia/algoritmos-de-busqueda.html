<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos de Búsqueda</title>

    <link rel="alternate" href="https://campusempresa.com/es/fundamentos_ia/algoritmos-de-busqueda" hreflang="es" />
    <link rel="alternate" href="https://campusempresa.com/es/fundamentos_ia/algoritmos-de-busqueda" hreflang="x-default" />
	<link rel="alternate" href="https://campusempresa.com/ca/fundamentos_ia/algoritmos-de-busqueda" hreflang="ca" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/es/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy<br> y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<b id="lit_lang_es" class="px-2">ES</b>
				|
				<a href="/ca/fundamentos_ia/algoritmos-de-busqueda" id="lnk_lang_ca" data-lang="ca" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/es/objective">El Proyecto</a>
				<a href="/es/about">Sobre nosotros</a>
				<a href="/es/contribute">Contribuir</a>
				<a href="/es/donate">Donaciones</a>
				<a href="/es/licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introducción</h1>
<div class='content'><p>Los algoritmos de búsqueda son fundamentales en el campo de la Inteligencia Artificial (IA). Estos algoritmos permiten encontrar soluciones a problemas específicos mediante la exploración de posibles estados o soluciones. En este tema, exploraremos los conceptos clave, los tipos de algoritmos de búsqueda y ejemplos prácticos para entender su funcionamiento.</p>
</div><h1>Conceptos Clave</h1>
<div class='content'><ul>
<li><strong>Espacio de Estados</strong>: Conjunto de todos los estados posibles que se pueden alcanzar desde el estado inicial.</li>
<li><strong>Nodo</strong>: Representación de un estado en el espacio de estados.</li>
<li><strong>Camino</strong>: Secuencia de nodos que lleva desde el estado inicial hasta el estado objetivo.</li>
<li><strong>Costo del Camino</strong>: Suma de los costos asociados con los pasos en el camino.</li>
<li><strong>Función de Evaluación</strong>: Función que asigna un valor a cada nodo, utilizado para decidir el siguiente nodo a explorar.</li>
</ul>
</div><h1>Tipos de Algoritmos de Búsqueda</h1>
<div class='content'></div><h2>Búsqueda No Informada</h2>
<div class='content'><ol>
<li>
<p><strong>Búsqueda en Anchura (Breadth-First Search, BFS)</strong></p>
<ul>
<li>Explora todos los nodos a un nivel de profundidad antes de pasar al siguiente nivel.</li>
<li>Utiliza una cola (FIFO) para almacenar los nodos por explorar.</li>
<li><strong>Ventajas</strong>: Garantiza encontrar la solución más corta si todos los costos de los pasos son iguales.</li>
<li><strong>Desventajas</strong>: Puede ser ineficiente en términos de memoria y tiempo.</li>
</ul>
<pre><code class="language-python">from collections import deque

def bfs(graph, start, goal):
    queue = deque([start])
    visited = set()
    while queue:
        node = queue.popleft()
        if node == goal:
            return True
        if node not in visited:
            visited.add(node)
            queue.extend(graph[node] - visited)
    return False

graph = {
    'A': {'B', 'C'},
    'B': {'A', 'D', 'E'},
    'C': {'A', 'F'},
    'D': {'B'},
    'E': {'B', 'F'},
    'F': {'C', 'E'}
}

print(bfs(graph, 'A', 'F'))  # Output: True
</code></pre>
</li>
<li>
<p><strong>Búsqueda en Profundidad (Depth-First Search, DFS)</strong></p>
<ul>
<li>Explora tan profundo como sea posible a lo largo de cada rama antes de retroceder.</li>
<li>Utiliza una pila (LIFO) para almacenar los nodos por explorar.</li>
<li><strong>Ventajas</strong>: Requiere menos memoria que BFS.</li>
<li><strong>Desventajas</strong>: No garantiza encontrar la solución más corta y puede quedar atrapado en ciclos.</li>
</ul>
<pre><code class="language-python">def dfs(graph, start, goal, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    if start == goal:
        return True
    for next_node in graph[start] - visited:
        if dfs(graph, next_node, goal, visited):
            return True
    return False

print(dfs(graph, 'A', 'F'))  # Output: True
</code></pre>
</li>
</ol>
</div><h2>Búsqueda Informada</h2>
<div class='content'><ol>
<li>
<p><em><em>Búsqueda A</em> (A-Star)</em>*</p>
<ul>
<li>Utiliza una función de evaluación <code>f(n) = g(n) + h(n)</code>, donde <code>g(n)</code> es el costo del camino desde el inicio hasta el nodo <code>n</code>, y <code>h(n)</code> es una heurística que estima el costo desde <code>n</code> hasta el objetivo.</li>
<li><strong>Ventajas</strong>: Es óptima y completa si la heurística es admisible (nunca sobreestima el costo real).</li>
<li><strong>Desventajas</strong>: Puede ser costosa en términos de memoria y tiempo.</li>
</ul>
<pre><code class="language-python">import heapq

def a_star(graph, start, goal, h):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: h(start)}

    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal:
            return reconstruct_path(came_from, current)
        for neighbor, cost in graph[current].items():
            tentative_g_score = g_score[current] + cost
            if tentative_g_score &lt; g_score.get(neighbor, float('inf')):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + h(neighbor)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return None

def reconstruct_path(came_from, current):
    total_path = [current]
    while current in came_from:
        current = came_from[current]
        total_path.append(current)
    return total_path[::-1]

graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'D': 1, 'E': 5},
    'C': {'A': 3, 'F': 2},
    'D': {'B': 1},
    'E': {'B': 5, 'F': 2},
    'F': {'C': 2, 'E': 2}
}

h = lambda x: {'A': 6, 'B': 5, 'C': 4, 'D': 3, 'E': 2, 'F': 1}[x]

print(a_star(graph, 'A', 'F', h))  # Output: ['A', 'C', 'F']
</code></pre>
</li>
</ol>
</div><h1>Comparación de Algoritmos</h1>
<div class='content'><p>| Algoritmo | Completo | Óptimo | Complejidad de Tiempo | Complejidad de Espacio |
|-----------|----------|--------|-----------------------|------------------------|
| BFS       | Sí       | Sí     | O(b^d)                | O(b^d)                 |
| DFS       | No       | No     | O(b^m)                | O(bm)                  |
| A*        | Sí       | Sí     | O(b^d)                | O(b^d)                 |</p>
<ul>
<li><strong>Completo</strong>: Encuentra una solución si existe.</li>
<li><strong>Óptimo</strong>: Encuentra la solución más corta.</li>
<li><strong>Complejidad de Tiempo</strong>: Tiempo requerido para encontrar la solución.</li>
<li><strong>Complejidad de Espacio</strong>: Memoria requerida para almacenar los nodos.</li>
</ul>
</div><h1>Conclusión</h1>
<div class='content'><p>Los algoritmos de búsqueda son herramientas esenciales en la Inteligencia Artificial para resolver problemas de manera eficiente. La elección del algoritmo adecuado depende de las características del problema, como el tamaño del espacio de estados y la necesidad de encontrar la solución más corta. La comprensión de estos algoritmos y su implementación práctica es crucial para desarrollar soluciones efectivas en IA.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
    <a href="/es/cookies">Més informació</a>
</div>	

	</div>    
</body>
</html>
