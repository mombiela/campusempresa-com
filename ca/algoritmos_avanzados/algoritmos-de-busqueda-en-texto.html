<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmes de Cerca en Text</title>

    <link rel="alternate" href="https://campusempresa.com/es/algoritmos_avanzados/algoritmos-de-busqueda-en-texto" hreflang="es" />
    <link rel="alternate" href="https://campusempresa.com/es/algoritmos_avanzados/algoritmos-de-busqueda-en-texto" hreflang="x-default" />
	<link rel="alternate" href="https://campusempresa.com/ca/algoritmos_avanzados/algoritmos-de-busqueda-en-texto" hreflang="ca" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/ca/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construint la societat d'avui<br> i del demà</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
							<a href="/es/algoritmos_avanzados/algoritmos-de-busqueda-en-texto" id="lnk_lang_es" data-lang="es" class="px-2">ES</a></b>
				|
				<b id="lit_lang_ca" class="px-2">CA</b>
								</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="objective">El Projecte</a>
				<a href="about">Sobre nosaltres</a>
				<a href="contribute">Contribuir</a>
				<a href="donate">Donacions</a>
				<a href="licence">Llicència</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introducció</h1>
<div class='content'><p>Els algorismes de cerca en text són fonamentals en el camp de la informàtica i tenen aplicacions en diverses àrees com la recuperació d'informació, la bioinformàtica i la compressió de dades. Aquest tema abordarà els algorismes més importants i eficients per cercar patrons en textos.</p>
</div><h1>Algorismes Clàssics de Cerca en Text</h1>
<div class='content'></div><h2>Cerca Ingènua</h2>
<div class='content'><p>L'algorisme de cerca ingènua és el més simple i directe, però també el menys eficient. Es basa en comparar el patró amb totes les possibles posicions en el text.</p>
<ul>
<li>
<p><strong>Avantatges</strong>:</p>
<ul>
<li>Fàcil d'implementar.</li>
<li>Funciona bé per a textos i patrons petits.</li>
</ul>
</li>
<li>
<p><strong>Desavantatges</strong>:</p>
<ul>
<li>Ineficient per a textos llargs.</li>
<li>Complexitat de temps: O((n-m+1) * m), on n és la longitud del text i m és la longitud del patró.</li>
</ul>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIG5haXZlX3NlYXJjaCh0ZXh0LCBwYXR0ZXJuKToKICAgIG4gPSBsZW4odGV4dCkKICAgIG0gPSBsZW4ocGF0dGVybikKICAgIGZvciBpIGluIHJhbmdlKG4gLSBtICsgMSk6CiAgICAgICAgaiA9IDAKICAgICAgICB3aGlsZSBqIDwgbSBhbmQgdGV4dFtpICsgal0gPT0gcGF0dGVybltqXToKICAgICAgICAgICAgaiArPSAxCiAgICAgICAgaWYgaiA9PSBtOgogICAgICAgICAgICBwcmludChmIlBhdHRlcm4gZm91bmQgYXQgaW5kZXgge2l9IikKCnRleHQgPSAiQUJBQkRBQkFDREFCQUJDQUJBQiIKcGF0dGVybiA9ICJBQkFCQ0FCQUIiCm5haXZlX3NlYXJjaCh0ZXh0LCBwYXR0ZXJuKQ=="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def naive_search(text, pattern):
    n = len(text)
    m = len(pattern)
    for i in range(n - m + 1):
        j = 0
        while j &lt; m and text[i + j] == pattern[j]:
            j += 1
        if j == m:
            print(f&quot;Pattern found at index {i}&quot;)

text = &quot;ABABDABACDABABCABAB&quot;
pattern = &quot;ABABCABAB&quot;
naive_search(text, pattern)</pre></div><div class='content'></div><h2>Algorisme de Knuth-Morris-Pratt (KMP)</h2>
<div class='content'><p>L'algorisme KMP millora l'eficiència evitant comparacions redundants mitjançant l'ús d'un arranjament de prefixos.</p>
<ul>
<li>
<p><strong>Avantatges</strong>:</p>
<ul>
<li>Més eficient que la cerca ingènua.</li>
<li>Complexitat de temps: O(n + m).</li>
</ul>
</li>
<li>
<p><strong>Desavantatges</strong>:</p>
<ul>
<li>Més complex d'implementar.</li>
</ul>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGttcF9zZWFyY2godGV4dCwgcGF0dGVybik6CiAgICBkZWYgY29tcHV0ZV9scHMocGF0dGVybik6CiAgICAgICAgbHBzID0gWzBdICogbGVuKHBhdHRlcm4pCiAgICAgICAgbGVuZ3RoID0gMAogICAgICAgIGkgPSAxCiAgICAgICAgd2hpbGUgaSA8IGxlbihwYXR0ZXJuKToKICAgICAgICAgICAgaWYgcGF0dGVybltpXSA9PSBwYXR0ZXJuW2xlbmd0aF06CiAgICAgICAgICAgICAgICBsZW5ndGggKz0gMQogICAgICAgICAgICAgICAgbHBzW2ldID0gbGVuZ3RoCiAgICAgICAgICAgICAgICBpICs9IDEKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGlmIGxlbmd0aCAhPSAwOgogICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGxwc1tsZW5ndGggLSAxXQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBscHNbaV0gPSAwCiAgICAgICAgICAgICAgICAgICAgaSArPSAxCiAgICAgICAgcmV0dXJuIGxwcwoKICAgIG4gPSBsZW4odGV4dCkKICAgIG0gPSBsZW4ocGF0dGVybikKICAgIGxwcyA9IGNvbXB1dGVfbHBzKHBhdHRlcm4pCiAgICBpID0gMAogICAgaiA9IDAKICAgIHdoaWxlIGkgPCBuOgogICAgICAgIGlmIHBhdHRlcm5bal0gPT0gdGV4dFtpXToKICAgICAgICAgICAgaSArPSAxCiAgICAgICAgICAgIGogKz0gMQogICAgICAgIGlmIGogPT0gbToKICAgICAgICAgICAgcHJpbnQoZiJQYXR0ZXJuIGZvdW5kIGF0IGluZGV4IHtpIC0gan0iKQogICAgICAgICAgICBqID0gbHBzW2ogLSAxXQogICAgICAgIGVsaWYgaSA8IG4gYW5kIHBhdHRlcm5bal0gIT0gdGV4dFtpXToKICAgICAgICAgICAgaWYgaiAhPSAwOgogICAgICAgICAgICAgICAgaiA9IGxwc1tqIC0gMV0KICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGkgKz0gMQoKdGV4dCA9ICJBQkFCREFCQUNEQUJBQkNBQkFCIgpwYXR0ZXJuID0gIkFCQUJDQUJBQiIKa21wX3NlYXJjaCh0ZXh0LCBwYXR0ZXJuKQ=="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def kmp_search(text, pattern):
    def compute_lps(pattern):
        lps = [0] * len(pattern)
        length = 0
        i = 1
        while i &lt; len(pattern):
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps

    n = len(text)
    m = len(pattern)
    lps = compute_lps(pattern)
    i = 0
    j = 0
    while i &lt; n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == m:
            print(f&quot;Pattern found at index {i - j}&quot;)
            j = lps[j - 1]
        elif i &lt; n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

text = &quot;ABABDABACDABABCABAB&quot;
pattern = &quot;ABABCABAB&quot;
kmp_search(text, pattern)</pre></div><div class='content'></div><h2>Algorisme de Boyer-Moore</h2>
<div class='content'><p>L'algorisme Boyer-Moore és un dels més eficients per a la cerca de patrons en text, utilitzant dues heurístiques: la heurística de mal caràcter i la heurística de bon sufix.</p>
<ul>
<li>
<p><strong>Avantatges</strong>:</p>
<ul>
<li>Molt eficient en la pràctica.</li>
<li>Complexitat de temps mitjana: O(n/m).</li>
</ul>
</li>
<li>
<p><strong>Desavantatges</strong>:</p>
<ul>
<li>Complex d'implementar.</li>
</ul>
</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGJveWVyX21vb3JlX3NlYXJjaCh0ZXh0LCBwYXR0ZXJuKToKICAgIGRlZiBiYWRfY2hhcl9oZXVyaXN0aWMocGF0dGVybik6CiAgICAgICAgYmFkX2NoYXIgPSBbLTFdICogMjU2CiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKHBhdHRlcm4pKToKICAgICAgICAgICAgYmFkX2NoYXJbb3JkKHBhdHRlcm5baV0pXSA9IGkKICAgICAgICByZXR1cm4gYmFkX2NoYXIKCiAgICBkZWYgZ29vZF9zdWZmaXhfaGV1cmlzdGljKHBhdHRlcm4pOgogICAgICAgIG0gPSBsZW4ocGF0dGVybikKICAgICAgICBnb29kX3N1ZmZpeCA9IFswXSAqIChtICsgMSkKICAgICAgICBib3JkZXJfcG9zID0gWzBdICogKG0gKyAxKQogICAgICAgIGkgPSBtCiAgICAgICAgaiA9IG0gKyAxCiAgICAgICAgYm9yZGVyX3Bvc1tpXSA9IGoKICAgICAgICB3aGlsZSBpID4gMDoKICAgICAgICAgICAgbWVudHJlIGogPD0gbSBpIHBhdHRlcm5baSAtIDFdICE9IHBhdHRlcm5baiAtIDFdOgogICAgICAgICAgICAgICAgaWYgZ29vZF9zdWZmaXhbal0gPT0gMDoKICAgICAgICAgICAgICAgICAgICBnb29kX3N1ZmZpeFtqXSA9IGogLSBpCiAgICAgICAgICAgICAgICBqID0gYm9yZGVyX3Bvc1tqXQogICAgICAgICAgICBpIC09IDEKICAgICAgICAgICAgaiAtPSAxCiAgICAgICAgICAgIGJvcmRlcl9wb3NbaV0gPSBqCiAgICAgICAgaiA9IGJvcmRlcl9wb3NbMF0KICAgICAgICBmb3IgaSBpbiByYW5nZShtICsgMSk6CiAgICAgICAgICAgIGlmIGdvb2Rfc3VmZml4W2ldID09IDA6CiAgICAgICAgICAgICAgICBnb29kX3N1ZmZpeFtpXSA9IGoKICAgICAgICAgICAgaWYgaSA9PSBqOgogICAgICAgICAgICAgICAgaiA9IGJvcmRlcl9wb3Nbal0KICAgICAgICByZXR1cm4gZ29vZF9zdWZmaXgKCiAgICBiYWRfY2hhciA9IGJhZF9jaGFyX2hldXJpc3RpYyhwYXR0ZXJuKQogICAgZ29vZF9zdWZmaXggPSBnb29kX3N1ZmZpeF9oZXVyaXN0aWMocGF0dGVybikKICAgIG4gPSBsZW4odGV4dCkKICAgIG0gPSBsZW4ocGF0dGVybikKICAgIHMgPSAwCiAgICB3aGlsZSBzIDw9IG4gLSBtOgogICAgICAgIGogPSBtIC0gMQogICAgICAgIHdoaWxlIGogPj0gMCBhbmQgcGF0dGVybltqXSA9PSB0ZXh0W3MgKyBqXToKICAgICAgICAgICAgaiAtPSAxCiAgICAgICAgaWYgaiA8IDA6CiAgICAgICAgICAgIHByaW50KGYiUGF0dGVybiBmb3VuZCBhdCBpbmRleCB7c30iKQogICAgICAgICAgICBzICs9IGdvb2Rfc3VmZml4WzBdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcyArPSBtYXgoZ29vZF9zdWZmaXhbaiArIDFdLCBqIC0gYmFkX2NoYXJbb3JkKHRleHRbcyArIGpdKV0pCgp0ZXh0ID0gIkFCQUJEQUJBQ0RBQkFCQ0FCQUIiCnBhdHRlcm4gPSAiQUJBQkNBQkFCIgpib3llcl9tb29yZV9zZWFyY2godGV4dCwgcGF0dGVybik="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def boyer_moore_search(text, pattern):
    def bad_char_heuristic(pattern):
        bad_char = [-1] * 256
        for i in range(len(pattern)):
            bad_char[ord(pattern[i])] = i
        return bad_char

    def good_suffix_heuristic(pattern):
        m = len(pattern)
        good_suffix = [0] * (m + 1)
        border_pos = [0] * (m + 1)
        i = m
        j = m + 1
        border_pos[i] = j
        while i &gt; 0:
            mentre j &lt;= m i pattern[i - 1] != pattern[j - 1]:
                if good_suffix[j] == 0:
                    good_suffix[j] = j - i
                j = border_pos[j]
            i -= 1
            j -= 1
            border_pos[i] = j
        j = border_pos[0]
        for i in range(m + 1):
            if good_suffix[i] == 0:
                good_suffix[i] = j
            if i == j:
                j = border_pos[j]
        return good_suffix

    bad_char = bad_char_heuristic(pattern)
    good_suffix = good_suffix_heuristic(pattern)
    n = len(text)
    m = len(pattern)
    s = 0
    while s &lt;= n - m:
        j = m - 1
        while j &gt;= 0 and pattern[j] == text[s + j]:
            j -= 1
        if j &lt; 0:
            print(f&quot;Pattern found at index {s}&quot;)
            s += good_suffix[0]
        else:
            s += max(good_suffix[j + 1], j - bad_char[ord(text[s + j])])

text = &quot;ABABDABACDABABCABAB&quot;
pattern = &quot;ABABCABAB&quot;
boyer_moore_search(text, pattern)</pre></div><div class='content'></div><h1>Comparació d'Algorismes</h1>
<div class='content'><p>| Algorisme         | Complexitat de Temps  | Avantatges                        | Desavantatges                    |
|-------------------|-----------------------|-----------------------------------|----------------------------------|
| Cerca Ingènua     | O((n-m+1) * m)        | Fàcil d'implementar               | Ineficient per a textos llargs   |
| KMP               | O(n + m)              | Evita comparacions redundants     | Més complex d'implementar        |
| Boyer-Moore       | O(n/m) (mitjana)      | Molt eficient en la pràctica      | Complex d'implementar            |</p>
</div><h1>Conclusió</h1>
<div class='content'><p>Els algorismes de cerca en text són eines essencials en la informàtica. L'elecció de l'algorisme adequat depèn del context i les necessitats específiques de l'aplicació. La cerca ingènua és simple però ineficient, mentre que KMP i Boyer-Moore ofereixen millores significatives en eficiència a costa d'una major complexitat d'implementació. Amb una comprensió sòlida d'aquests algorismes, els professionals poden abordar una àmplia gamma de problemes de cerca en text de manera efectiva.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicitat</h1>
			<p>Aquest espai està destinat a publicitat.</p>
			<p>Si vols ser patrocinador, contacta amb nosaltres per incloure enllaços en aquesta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Gràcies per col·laborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Tots els drets reservats</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
    <a href="cookies">Més informació</a>
</div>	

	</div>    
</body>
</html>
