<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmes de Cerca de Camins</title>

    <link rel="alternate" href="https://campusempresa.com/es/ia_videojuegos/algoritmos-de-busqueda-de-caminos" hreflang="es" />
    <link rel="alternate" href="https://campusempresa.com/es/ia_videojuegos/algoritmos-de-busqueda-de-caminos" hreflang="x-default" />
	<link rel="alternate" href="https://campusempresa.com/ca/ia_videojuegos/algoritmos-de-busqueda-de-caminos" hreflang="ca" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/ca/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construint la societat d'avui<br> i del demà</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
							<a href="/es/ia_videojuegos/algoritmos-de-busqueda-de-caminos" id="lnk_lang_es" data-lang="es" class="px-2">ES</a></b>
				|
				<b id="lit_lang_ca" class="px-2">CA</b>
								</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="objective">El Projecte</a>
				<a href="about">Sobre nosaltres</a>
				<a href="contribute">Contribuir</a>
				<a href="donate">Donacions</a>
				<a href="licence">Llicència</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introducció</h1>
<div class='content'><p>En el desenvolupament de videojocs, els algorismes de cerca de camins són fonamentals per a la intel·ligència artificial (IA) dels personatges no jugables (NPCs). Aquests algorismes permeten que els NPCs trobin la ruta més eficient des d'un punt d'inici fins a una destinació, evitant obstacles i optimitzant el temps de recorregut.</p>
</div><h1>Conceptes Clau</h1>
<div class='content'><ul>
<li><strong>Graf</strong>: Representació abstracta d'un conjunt de nodes (o vèrtexs) i les connexions (o arestes) entre ells.</li>
<li><strong>Node</strong>: Punt en el graf que representa una posició en l'espai del joc.</li>
<li><strong>Aresta</strong>: Connexió entre dos nodes que pot tenir un cost associat.</li>
<li><strong>Cost</strong>: Valor que representa la &quot;dificultat&quot; o &quot;distància&quot; per moure's d'un node a un altre.</li>
<li><strong>Heurística</strong>: Estimació del cost restant des d'un node fins a la destinació.</li>
</ul>
</div><h1>Algoritmes de Cerca de Camins</h1>
<div class='content'></div><h2>Cerca en Amplada (Breadth-First Search, BFS)</h2>
<div class='content'><p>L'algorisme BFS explora tots els nodes a la mateixa distància del node inicial abans de passar als nodes a major distància. És útil per trobar el camí més curt en grafs no ponderats.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZnJvbSBjb2xsZWN0aW9ucyBpbXBvcnQgZGVxdWUKCmRlZiBiZnMoZ3JhcGgsIHN0YXJ0LCBnb2FsKToKICAgIHF1ZXVlID0gZGVxdWUoW3N0YXJ0XSkKICAgIHZpc2l0ZWQgPSBzZXQoKQogICAgcGFyZW50ID0ge3N0YXJ0OiBOb25lfQoKICAgIHdoaWxlIHF1ZXVlOgogICAgICAgIGN1cnJlbnQgPSBxdWV1ZS5wb3BsZWZ0KCkKICAgICAgICBpZiBjdXJyZW50ID09IGdvYWw6CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZm9yIG5laWdoYm9yIGluIGdyYXBoW2N1cnJlbnRdOgogICAgICAgICAgICBpZiBuZWlnaGJvciBub3QgaW4gdmlzaXRlZDoKICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKG5laWdoYm9yKQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnQKICAgICAgICAgICAgICAgIHF1ZXVlLmFwcGVuZChuZWlnaGJvcikKCiAgICBwYXRoID0gW10KICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>from collections import deque

def bfs(graph, start, goal):
    queue = deque([start])
    visited = set()
    parent = {start: None}

    while queue:
        current = queue.popleft()
        if current == goal:
            break
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                queue.append(neighbor)

    path = []
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h2>Cerca en Profunditat (Depth-First Search, DFS)</h2>
<div class='content'><p>L'algorisme DFS explora tan lluny com sigui possible al llarg de cada branca abans de retrocedir. És útil per explorar totes les possibles rutes, encara que no garanteix el camí més curt.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGRmcyhncmFwaCwgc3RhcnQsIGdvYWwpOgogICAgc3RhY2sgPSBbc3RhcnRdCiAgICB2aXNpdGVkID0gc2V0KCkKICAgIHBhcmVudCA9IHtzdGFydDogTm9uZX0KCiAgICB3aGlsZSBzdGFjazoKICAgICAgICBjdXJyZW50ID0gc3RhY2sucG9wKCkKICAgICAgICBpZiBjdXJyZW50ID09IGdvYWw6CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZm9yIG5laWdoYm9yIGluIGdyYXBoW2N1cnJlbnRdOgogICAgICAgICAgICBpZiBuZWlnaGJvciBub3QgaW4gdmlzaXRlZDoKICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKG5laWdoYm9yKQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnQKICAgICAgICAgICAgICAgIHN0YWNrLmFwcGVuZChuZWlnaGJvcikKCiAgICBwYXRoID0gW10KICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def dfs(graph, start, goal):
    stack = [start]
    visited = set()
    parent = {start: None}

    while stack:
        current = stack.pop()
        if current == goal:
            break
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                stack.append(neighbor)

    path = []
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h2>Algorisme de Dijkstra</h2>
<div class='content'><p>L'algorisme de Dijkstra troba el camí més curt des d'un node inicial a tots els altres nodes en un graf ponderat.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0LCBnb2FsKToKICAgIHF1ZXVlID0gWygwLCBzdGFydCldCiAgICBkaXN0YW5jZXMgPSB7c3RhcnQ6IDB9CiAgICBwYXJlbnQgPSB7c3RhcnQ6IE5vbmV9CgogICAgd2hpbGUgcXVldWU6CiAgICAgICAgY3VycmVudF9kaXN0YW5jZSwgY3VycmVudF9ub2RlID0gaGVhcHEuaGVhcHBvcChxdWV1ZSkKICAgICAgICBpZiBjdXJyZW50X25vZGUgPT0gZ29hbDoKICAgICAgICAgICAgYnJlYWsKICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtjdXJyZW50X25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3RhbmNlID0gY3VycmVudF9kaXN0YW5jZSArIHdlaWdodAogICAgICAgICAgICBpZiBuZWlnaGJvciBub3QgaW4gZGlzdGFuY2VzIG9yIGRpc3RhbmNlIDwgZGlzdGFuY2VzW25laWdoYm9yXToKICAgICAgICAgICAgICAgIGRpc3RhbmNlc1tuZWlnaGJvcl0gPSBkaXN0YW5jZQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnRfbm9kZQogICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2gocXVldWUsIChkaXN0YW5jZSwgbmVpZ2hib3IpKQoKICAgIHBhdGggPSBbXQogICAgY3VycmVudCA9IGdvYWwKICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def dijkstra(graph, start, goal):
    queue = [(0, start)]
    distances = {start: 0}
    parent = {start: None}

    while queue:
        current_distance, current_node = heapq.heappop(queue)
        if current_node == goal:
            break
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if neighbor not in distances or distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                parent[neighbor] = current_node
                heapq.heappush(queue, (distance, neighbor))

    path = []
    current = goal
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h2>Algorisme A*</h2>
<div class='content'><p>L'algorisme A* combina els avantatges de Dijkstra i BFS, utilitzant una heurística per guiar la cerca i trobar el camí més curt de manera eficient.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgaGV1cmlzdGljKGEsIGIpOgogICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgKyBhYnMoYVsxXSAtIGJbMV0pCgpkZWYgYV9zdGFyKGdyYXBoLCBzdGFydCwgZ29hbCk6CiAgICBxdWV1ZSA9IFsoMCwgc3RhcnQpXQogICAgZ19jb3N0cyA9IHtzdGFydDogMH0KICAgIGZfY29zdHMgPSB7c3RhcnQ6IGhldXJpc3RpYyhzdGFydCwgZ29hbCl9CiAgICBwYXJlbnQgPSB7c3RhcnQ6IE5vbmV9CgogICAgd2hpbGUgcXVldWU6CiAgICAgICAgXywgY3VycmVudCA9IGhlYXBxLmhlYXBwb3AocXVldWUpCiAgICAgICAgaWYgY3VycmVudCA9PSBnb2FsOgogICAgICAgICAgICBicmVhawogICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW2N1cnJlbnRdLml0ZW1zKCk6CiAgICAgICAgICAgIHRlbnRhdGl2ZV9nX2Nvc3QgPSBnX2Nvc3RzW2N1cnJlbnRdICsgd2VpZ2h0CiAgICAgICAgICAgIGlmIG5laWdoYm9yIG5vdCBpbiBnX2Nvc3RzIG8gdGVudGF0aXZlX2dfY29zdCA8IGdfY29zdHNbbmVpZ2hib3JdOgogICAgICAgICAgICAgICAgZ19jb3N0c1tuZWlnaGJvcl0gPSB0ZW50YXRpdmVfZ19jb3N0CiAgICAgICAgICAgICAgICBmX2Nvc3RzW25laWdoYm9yXSA9IHRlbnRhdGl2ZV9nX2Nvc3QgKyBoZXVyaXN0aWMobmVpZ2hib3IsIGdvYWwpCiAgICAgICAgICAgICAgICBwYXJlbnRbbmVpZ2hib3JdID0gY3VycmVudAogICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2gocXVldWUsIChmX2Nvc3RzW25laWdoYm9yXSwgbmVpZ2hib3IpKQoKICAgIHBhdGggPSBbXQogICAgY3VycmVudCA9IGdvYWwKICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star(graph, start, goal):
    queue = [(0, start)]
    g_costs = {start: 0}
    f_costs = {start: heuristic(start, goal)}
    parent = {start: None}

    while queue:
        _, current = heapq.heappop(queue)
        if current == goal:
            break
        for neighbor, weight in graph[current].items():
            tentative_g_cost = g_costs[current] + weight
            if neighbor not in g_costs o tentative_g_cost &lt; g_costs[neighbor]:
                g_costs[neighbor] = tentative_g_cost
                f_costs[neighbor] = tentative_g_cost + heuristic(neighbor, goal)
                parent[neighbor] = current
                heapq.heappush(queue, (f_costs[neighbor], neighbor))

    path = []
    current = goal
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h1>Comparació d'Algoritmes</h1>
<div class='content'><p>| Algorisme  | Complexitat | Ús Ideal                          | Avantatges                         | Desavantatges                      |
|------------|-------------|------------------------------------|------------------------------------|------------------------------------|
| BFS        | O(V + E)    | Grafs no ponderats                | Troba el camí més curt             | No eficient en grafs grans         |
| DFS        | O(V + E)    | Exploració completa               | Simple d'implementar               | No garanteix el camí més curt      |
| Dijkstra   | O(V^2)      | Grafs ponderats                   | Troba el camí més curt             | Lent en grafs densos               |
| A*         | O(E)        | Grafs ponderats amb heurística    | Ràpid i eficient                   | Depèn de la heurística             |</p>
</div><h1>Conclusió</h1>
<div class='content'><p>Els algorismes de cerca de camins són essencials per a la IA en videojocs, permetent als NPCs navegar de manera eficient i realista. Cada algorisme té els seus propis avantatges i desavantatges, i l'elecció de l'algorisme adequat depèn del context del joc i els requisits específics de rendiment i precisió.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicitat</h1>
			<p>Aquest espai està destinat a publicitat.</p>
			<p>Si vols ser patrocinador, contacta amb nosaltres per incloure enllaços en aquesta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Gràcies per col·laborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Tots els drets reservats</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Entès!</a>
    <a href="cookies">Més informació</a>
</div>	

	</div>    
</body>
</html>
