<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entendiendo el Pipeline de OpenGL</title>

    <link rel="alternate" href="https://campusempresa.com/mod/open_gl/01-04-opengl-pipeline" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/open_gl/01-04-opengl-pipeline" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/open_gl/01-04-opengl-pipeline" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="/js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-12 col-md-6 p-2 p-md-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-12 col-md-6 p-2 p-md-0 text-end">
				<a href="https://enterprisecampus.net/mod/open_gl/01-04-opengl-pipeline" class="px-2">EN</a></b>
	|
	<b class="px-2">ES</b>
	|
	<a href="https://campusempresa.cat/mod/open_gl/01-04-opengl-pipeline" class="px-2">CA</a>
<br>
			<cite>Construyendo la sociedad de hoy y del mañana</cite>
		</div>
	</div>
</div>
<div id="subheader" class="container-xxl">
	<div class="row">
		<div class="col-12 p-2 p-md-0 m-0 text-end">
			<a href="/objective">El Proyecto</a> | 
<a href="/about">Sobre nosotros</a> | 
<a href="/contribute">Contribuir</a> | 
<a href="/donate">Donaciones</a> | 
<a href="/licence">Licencia</a>
		</div>
	</div>
</div>

<div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				 					<a href="/categ/languages">Lenguajes de Programación</a>
				 					<a href="/categ/frameworks">Frameworks y Librerías</a>
				 					<a href="/categ/tech-tools">Herramientas Técnicas</a>
				 					<a href="/categ/foundations">Fundamentos Teóricos</a>
				 					<a href="/categ/soft-skills">Habilidades Sociales</a>
							</div>
		</div>
	</div>
</div>
		
<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
				<div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='01-03-first-opengl-program' title="Creando tu Primer Programa OpenGL">
				<span class="d-none d-md-inline">&#x25C4; Anterior</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
					<a href="./"><h2 style="text-decoration:underline">Entendiendo el Pipeline de OpenGL</h2></a>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='02-01-drawing-basic-shapes' title="Dibujando Formas Básicas">
				<span class="d-none d-md-inline">Siguiente &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>
<div class='content'><p>El pipeline de OpenGL es una serie de etapas que los datos gráficos atraviesan para ser renderizados en la pantalla. Comprender este pipeline es crucial para aprovechar al máximo las capacidades de OpenGL y optimizar el rendimiento de tus aplicaciones gráficas.</p>
</div><h1><p>Etapas del Pipeline de OpenGL</p>
</h1>
<div class='content'><p>El pipeline de OpenGL se puede dividir en varias etapas principales:</p>
<ol>
<li><strong>Especificación de Vértices</strong></li>
<li><strong>Transformaciones de Vértices</strong></li>
<li><strong>Montaje de Primitivas</strong></li>
<li><strong>Rasterización</strong></li>
<li><strong>Fragment Shader</strong></li>
<li><strong>Pruebas y Operaciones de Per-Fragmento</strong></li>
<li><strong>Mezcla y Escritura en el Framebuffer</strong></li>
</ol>
</div><h2><ol>
<li>Especificación de Vértices</li>
</ol>
</h2>
<div class='content'><p>En esta etapa, los datos de los vértices (posiciones, colores, normales, coordenadas de textura, etc.) se especifican y se envían a la GPU. Estos datos se almacenan en buffers de vértices.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRWplbXBsbyBkZSBlc3BlY2lmaWNhY2nDs24gZGUgdsOpcnRpY2VzIGVuIE9wZW5HTApHTHVpbnQgVkJPOwpnbEdlbkJ1ZmZlcnMoMSwgJlZCTyk7CmdsQmluZEJ1ZmZlcihHTF9BUlJBWV9CVUZGRVIsIFZCTyk7CmdsQnVmZmVyRGF0YShHTF9BUlJBWV9CVUZGRVIsIHNpemVvZih2ZXJ0aWNlcyksIHZlcnRpY2VzLCBHTF9TVEFUSUNfRFJBVyk7"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Ejemplo de especificaci&oacute;n de v&eacute;rtices en OpenGL
GLuint VBO;
glGenBuffers(1, &amp;VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</pre></div><div class='content'></div><h2><ol start="2">
<li>Transformaciones de Vértices</li>
</ol>
</h2>
<div class='content'><p>Los vértices especificados se transforman mediante shaders de vértices. Estas transformaciones pueden incluir traslaciones, rotaciones, escalados y proyecciones.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRWplbXBsbyBkZSB1biBzaGFkZXIgZGUgdsOpcnRpY2VzIHNpbXBsZQpjb25zdCBjaGFyKiB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBSIigKI3ZlcnNpb24gMzMwIGNvcmUKbGF5b3V0IChsb2NhdGlvbiA9IDApIGluIHZlYzMgYVBvczsKdW5pZm9ybSBtYXQ0IG1vZGVsOwp1bmlmb3JtIG1hdDQgdmlldzsKdW5pZm9ybSBtYXQ0IHByb2plY3Rpb247CnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZpZXcgKiBtb2RlbCAqIHZlYzQoYVBvcywgMS4wKTsKfQopIjs="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Ejemplo de un shader de v&eacute;rtices simple
const char* vertexShaderSource = R&quot;(
#version 330 core
layout (location = 0) in vec3 aPos;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
)&quot;;</pre></div><div class='content'></div><h2><ol start="3">
<li>Montaje de Primitivas</li>
</ol>
</h2>
<div class='content'><p>Los vértices transformados se ensamblan en primitivas (puntos, líneas, triángulos, etc.). Esta etapa define cómo se conectan los vértices para formar las primitivas.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRWplbXBsbyBkZSBkaWJ1am8gZGUgcHJpbWl0aXZhcwpnbERyYXdBcnJheXMoR0xfVFJJQU5HTEVTLCAwLCAzKTs="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Ejemplo de dibujo de primitivas
glDrawArrays(GL_TRIANGLES, 0, 3);</pre></div><div class='content'></div><h2><ol start="4">
<li>Rasterización</li>
</ol>
</h2>
<div class='content'><p>Las primitivas ensambladas se convierten en fragmentos. La rasterización es el proceso de convertir primitivas en una serie de fragmentos que representan los píxeles en la pantalla.</p>
</div><h2><ol start="5">
<li>Fragment Shader</li>
</ol>
</h2>
<div class='content'><p>Cada fragmento generado pasa por el fragment shader, donde se calculan los colores y otros atributos de los fragmentos. Esta etapa es crucial para efectos de iluminación, texturizado y otros efectos visuales.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRWplbXBsbyBkZSB1biBzaGFkZXIgZGUgZnJhZ21lbnRvcyBzaW1wbGUKY29uc3QgY2hhciogZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBSIigKI3ZlcnNpb24gMzMwIGNvcmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwp2b2lkIG1haW4oKQp7CiAgICBGcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC41LCAwLjIsIDEuMCk7Cn0KKSI7"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Ejemplo de un shader de fragmentos simple
const char* fragmentShaderSource = R&quot;(
#version 330 core
out vec4 FragColor;
void main()
{
    FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
)&quot;;</pre></div><div class='content'></div><h2><ol start="6">
<li>Pruebas y Operaciones de Per-Fragmento</li>
</ol>
</h2>
<div class='content'><p>Los fragmentos procesados pasan por varias pruebas (profundidad, stencil, etc.) y operaciones (mezcla, descarte, etc.) antes de ser escritos en el framebuffer.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRWplbXBsbyBkZSBoYWJpbGl0YWNpw7NuIGRlIHBydWViYXMgZGUgcHJvZnVuZGlkYWQKZ2xFbmFibGUoR0xfREVQVEhfVEVTVCk7"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Ejemplo de habilitaci&oacute;n de pruebas de profundidad
glEnable(GL_DEPTH_TEST);</pre></div><div class='content'></div><h2><ol start="7">
<li>Mezcla y Escritura en el Framebuffer</li>
</ol>
</h2>
<div class='content'><p>Finalmente, los fragmentos que pasan todas las pruebas se mezclan (si es necesario) y se escriben en el framebuffer, resultando en la imagen final que se muestra en la pantalla.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRWplbXBsbyBkZSBoYWJpbGl0YWNpw7NuIGRlIG1lemNsYQpnbEVuYWJsZShHTF9CTEVORCk7CmdsQmxlbmRGdW5jKEdMX1NSQ19BTFBIQSwgR0xfT05FX01JTlVTX1NSQ19BTFBIQSk7"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Ejemplo de habilitaci&oacute;n de mezcla
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</pre></div><div class='content'></div><h1><p>Ejercicio Práctico</p>
</h1>
<div class='content'></div><h2><p>Ejercicio 1: Implementar un Pipeline Básico</p>
</h2>
<div class='content'><ol>
<li><strong>Objetivo:</strong> Crear un programa OpenGL que dibuje un triángulo en la pantalla utilizando el pipeline de OpenGL.</li>
<li><strong>Pasos:</strong>
<ul>
<li>Configura tu entorno de desarrollo.</li>
<li>Especifica los vértices del triángulo.</li>
<li>Crea y compila shaders de vértices y fragmentos.</li>
<li>Configura las transformaciones de vértices.</li>
<li>Dibuja el triángulo.</li>
</ul>
</li>
</ol>
</div><h2><p>Solución</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPEdML2dsZXcuaD4KI2luY2x1ZGUgPEdMRlcvZ2xmdzMuaD4KCi8vIFbDqXJ0aWNlcyBkZWwgdHJpw6FuZ3VsbwpmbG9hdCB2ZXJ0aWNlc1tdID0gewogICAgLTAuNWYsIC0wLjVmLCAwLjBmLAogICAgIDAuNWYsIC0wLjVmLCAwLjBmLAogICAgIDAuMGYsICAwLjVmLCAwLjBmCn07CgovLyBTaGFkZXJzCmNvbnN0IGNoYXIqIHZlcnRleFNoYWRlclNvdXJjZSA9IFIiKAojdmVyc2lvbiAzMzAgY29yZQpsYXlvdXQgKGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhUG9zOwp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvcywgMS4wKTsKfQopIjsKCmNvbnN0IGNoYXIqIGZyYWdtZW50U2hhZGVyU291cmNlID0gUiIoCiN2ZXJzaW9uIDMzMCBjb3JlCm91dCB2ZWM0IEZyYWdDb2xvcjsKdm9pZCBtYWluKCkKewogICAgRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuNSwgMC4yLCAxLjApOwp9CikiOwoKaW50IG1haW4oKSB7CiAgICAvLyBJbmljaWFsaXphY2nDs24gZGUgR0xGVwogICAgaWYgKCFnbGZ3SW5pdCgpKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgfQoKICAgIC8vIENyZWFyIHVuYSB2ZW50YW5hCiAgICBHTEZXd2luZG93KiB3aW5kb3cgPSBnbGZ3Q3JlYXRlV2luZG93KDgwMCwgNjAwLCAiT3BlbkdMIFBpcGVsaW5lIiwgTlVMTCwgTlVMTCk7CiAgICBpZiAoIXdpbmRvdykgewogICAgICAgIGdsZndUZXJtaW5hdGUoKTsKICAgICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBnbGZ3TWFrZUNvbnRleHRDdXJyZW50KHdpbmRvdyk7CgogICAgLy8gSW5pY2lhbGl6YWNpw7NuIGRlIEdMRVcKICAgIGlmIChnbGV3SW5pdCgpICE9IEdMRVdfT0spIHsKICAgICAgICByZXR1cm4gLTE7CiAgICB9CgogICAgLy8gQ3JlYXIgeSBjb21waWxhciBlbCBzaGFkZXIgZGUgdsOpcnRpY2VzCiAgICBHTHVpbnQgdmVydGV4U2hhZGVyID0gZ2xDcmVhdGVTaGFkZXIoR0xfVkVSVEVYX1NIQURFUik7CiAgICBnbFNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIDEsICZ2ZXJ0ZXhTaGFkZXJTb3VyY2UsIE5VTEwpOwogICAgZ2xDb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7CgogICAgLy8gQ3JlYXIgeSBjb21waWxhciBlbCBzaGFkZXIgZGUgZnJhZ21lbnRvcwogICAgR0x1aW50IGZyYWdtZW50U2hhZGVyID0gZ2xDcmVhdGVTaGFkZXIoR0xfRlJBR01FTlRfU0hBREVSKTsKICAgIGdsU2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCAxLCAmZnJhZ21lbnRTaGFkZXJTb3VyY2UsIE5VTEwpOwogICAgZ2xDb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTsKCiAgICAvLyBDcmVhciBlbCBwcm9ncmFtYSBkZSBzaGFkZXIgeSBlbmxhemFyIGxvcyBzaGFkZXJzCiAgICBHTHVpbnQgc2hhZGVyUHJvZ3JhbSA9IGdsQ3JlYXRlUHJvZ3JhbSgpOwogICAgZ2xBdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyKTsKICAgIGdsQXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTsKICAgIGdsTGlua1Byb2dyYW0oc2hhZGVyUHJvZ3JhbSk7CgogICAgLy8gRWxpbWluYXIgbG9zIHNoYWRlcnMgeWEgcXVlIG5vIHNvbiBuZWNlc2FyaW9zIGRlc3B1w6lzIGRlIGVubGF6YXJsb3MKICAgIGdsRGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7CiAgICBnbERlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7CgogICAgLy8gQ3JlYXIgdW4gVkJPIHkgdW4gVkFPCiAgICBHTHVpbnQgVkJPLCBWQU87CiAgICBnbEdlblZlcnRleEFycmF5cygxLCAmVkFPKTsKICAgIGdsR2VuQnVmZmVycygxLCAmVkJPKTsKCiAgICAvLyBFbmxhemFyIGVsIFZBTwogICAgZ2xCaW5kVmVydGV4QXJyYXkoVkFPKTsKCiAgICAvLyBFbmxhemFyIGVsIFZCTyB5IGNhcmdhciBsb3MgZGF0b3MgZGUgbG9zIHbDqXJ0aWNlcwogICAgZ2xCaW5kQnVmZmVyKEdMX0FSUkFZX0JVRkZFUiwgVkJPKTsKICAgIGdsQnVmZmVyRGF0YShHTF9BUlJBWV9CVUZGRVIsIHNpemVvZih2ZXJ0aWNlcyksIHZlcnRpY2VzLCBHTF9TVEFUSUNfRFJBVyk7CgogICAgLy8gRXNwZWNpZmljYXIgZWwgZm9ybWF0byBkZSBsb3MgZGF0b3MgZGUgbG9zIHbDqXJ0aWNlcwogICAgZ2xWZXJ0ZXhBdHRyaWJQb2ludGVyKDAsIDMsIEdMX0ZMT0FULCBHTF9GQUxTRSwgMyAqIHNpemVvZihmbG9hdCksICh2b2lkKikwKTsKICAgIGdsRW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMCk7CgogICAgLy8gRGVzZW5sYXphciBlbCBWQk8geSBlbCBWQU8KICAgIGdsQmluZEJ1ZmZlcihHTF9BUlJBWV9CVUZGRVIsIDApOwogICAgZ2xCaW5kVmVydGV4QXJyYXkoMCk7CgogICAgLy8gQnVjbGUgZGUgcmVuZGVyaXphZG8KICAgIHdoaWxlICghZ2xmd1dpbmRvd1Nob3VsZENsb3NlKHdpbmRvdykpIHsKICAgICAgICAvLyBMaW1waWFyIGVsIGJ1ZmZlciBkZSBjb2xvcgogICAgICAgIGdsQ2xlYXIoR0xfQ09MT1JfQlVGRkVSX0JJVCk7CgogICAgICAgIC8vIFVzYXIgZWwgcHJvZ3JhbWEgZGUgc2hhZGVyCiAgICAgICAgZ2xVc2VQcm9ncmFtKHNoYWRlclByb2dyYW0pOwoKICAgICAgICAvLyBFbmxhemFyIGVsIFZBTyB5IGRpYnVqYXIgZWwgdHJpw6FuZ3VsbwogICAgICAgIGdsQmluZFZlcnRleEFycmF5KFZBTyk7CiAgICAgICAgZ2xEcmF3QXJyYXlzKEdMX1RSSUFOR0xFUywgMCwgMyk7CgogICAgICAgIC8vIEludGVyY2FtYmlhciBsb3MgYnVmZmVycwogICAgICAgIGdsZndTd2FwQnVmZmVycyh3aW5kb3cpOwoKICAgICAgICAvLyBQcm9jZXNhciBldmVudG9zCiAgICAgICAgZ2xmd1BvbGxFdmVudHMoKTsKICAgIH0KCiAgICAvLyBMaW1waWFyIHJlY3Vyc29zCiAgICBnbERlbGV0ZVZlcnRleEFycmF5cygxLCAmVkFPKTsKICAgIGdsRGVsZXRlQnVmZmVycygxLCAmVkJPKTsKICAgIGdsRGVsZXRlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTsKCiAgICAvLyBUZXJtaW5hciBHTEZXCiAgICBnbGZ3VGVybWluYXRlKCk7CiAgICByZXR1cm4gMDsKfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;

// V&eacute;rtices del tri&aacute;ngulo
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};

// Shaders
const char* vertexShaderSource = R&quot;(
#version 330 core
layout (location = 0) in vec3 aPos;
void main()
{
    gl_Position = vec4(aPos, 1.0);
}
)&quot;;

const char* fragmentShaderSource = R&quot;(
#version 330 core
out vec4 FragColor;
void main()
{
    FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
)&quot;;

int main() {
    // Inicializaci&oacute;n de GLFW
    if (!glfwInit()) {
        return -1;
    }

    // Crear una ventana
    GLFWwindow* window = glfwCreateWindow(800, 600, &quot;OpenGL Pipeline&quot;, NULL, NULL);
    if (!window) {
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    // Inicializaci&oacute;n de GLEW
    if (glewInit() != GLEW_OK) {
        return -1;
    }

    // Crear y compilar el shader de v&eacute;rtices
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);
    glCompileShader(vertexShader);

    // Crear y compilar el shader de fragmentos
    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);

    // Crear el programa de shader y enlazar los shaders
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    // Eliminar los shaders ya que no son necesarios despu&eacute;s de enlazarlos
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // Crear un VBO y un VAO
    GLuint VBO, VAO;
    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);

    // Enlazar el VAO
    glBindVertexArray(VAO);

    // Enlazar el VBO y cargar los datos de los v&eacute;rtices
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // Especificar el formato de los datos de los v&eacute;rtices
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // Desenlazar el VBO y el VAO
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    // Bucle de renderizado
    while (!glfwWindowShouldClose(window)) {
        // Limpiar el buffer de color
        glClear(GL_COLOR_BUFFER_BIT);

        // Usar el programa de shader
        glUseProgram(shaderProgram);

        // Enlazar el VAO y dibujar el tri&aacute;ngulo
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        // Intercambiar los buffers
        glfwSwapBuffers(window);

        // Procesar eventos
        glfwPollEvents();
    }

    // Limpiar recursos
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);
    glDeleteProgram(shaderProgram);

    // Terminar GLFW
    glfwTerminate();
    return 0;
}</pre></div><div class='content'></div><h2><p>Retroalimentación y Consejos</p>
</h2>
<div class='content'><ul>
<li><strong>Error Común:</strong> No enlazar correctamente los buffers y arrays de vértices puede resultar en que nada se dibuje en la pantalla. Asegúrate de seguir el orden correcto de enlazado y desenlazado.</li>
<li><strong>Consejo:</strong> Utiliza herramientas de depuración como <code>glGetShaderiv</code> y <code>glGetProgramiv</code> para verificar errores de compilación y enlace de shaders.</li>
</ul>
</div><h1><p>Conclusión</p>
</h1>
<div class='content'><p>En esta sección, hemos explorado el pipeline de OpenGL y sus etapas clave. Comprender este flujo de datos es esencial para desarrollar aplicaciones gráficas eficientes y efectivas. En el próximo módulo, profundizaremos en el renderizado básico, comenzando con el dibujo de formas simples.</p>
</div><div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='01-03-first-opengl-program' title="Creando tu Primer Programa OpenGL">
				<span class="d-none d-md-inline">&#x25C4; Anterior</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='02-01-drawing-basic-shapes' title="Dibujando Formas Básicas">
				<span class="d-none d-md-inline">Siguiente &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Usamos cookies para mejorar tu experiencia de uso y ofrecer contenidos adaptados a tus intereses.
    <a href="#" id="btn_accept_cookies" class="button">Aceptar</a>
    <a href="/cookies">Mas información</a>
</div>	

	</div>    
</body>
</html>
