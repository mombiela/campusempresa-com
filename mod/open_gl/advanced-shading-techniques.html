<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Técnicas Avanzadas de Sombreado</title>

    <link rel="alternate" href="https://campusempresa.com/mod/open_gl/advanced-shading-techniques" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/open_gl/advanced-shading-techniques" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/open_gl/advanced-shading-techniques" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body  class="test" >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<a href="https://enterprisecampus.net/mod/open_gl/advanced-shading-techniques" class="px-2">EN</a></b>
				|
				<b class="px-2">ES</b>
				|
				<a href="https://campusempresa.cat/mod/open_gl/advanced-shading-techniques" class="px-2">CA</a>
								</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">El Proyecto</a>
				<a href="/about">Sobre nosotros</a>
				<a href="/contribute">Contribuir</a>
				<a href="/donate">Donaciones</a>
				<a href="/licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
									<div class="assert">
						<p><b>Atención!</b> Ha habido un error en la generación del curso y puede contener errores de traducción.Estamos trabajando para solucinarlo por lo que se deben usar los contenidos con cuidado.Se puede consultar el contenido correcto en otro idioma en el siguiente enlace:<br>
						<a href="https://enterprisecampus.net/mod/open_gl/advanced-shading-techniques">https://enterprisecampus.net/mod/open_gl/advanced-shading-techniques</a></p>
					</div>
								<div class='row navigation'>
	<div class='col-4'>
					<a href='framebuffers-and-renderbuffers'>&#x25C4;Framebuffers y Renderbuffers</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Técnicas Avanzadas de Sombreado</a>
	</div>
	<div class='col-4 text-end'>
					<a href='shadow-mapping'>Mapeo de Sombras &#x25BA;</a>
			</div>
</div>
<div class='content'></div><h1>Introducción al Sombreado en OpenGL</h1>
<div class='content'><p>El sombreado es un aspecto crucial del renderizado en OpenGL, permitiendo la creación de efectos de iluminación y superficies realistas. Esta sección cubrirá técnicas avanzadas de sombreado que van más allá de los modelos de iluminación básicos.</p>
</div><h1>Conceptos Clave</h1>
<div class='content'><ul>
<li><strong>Sombreado Phong</strong>: Una técnica de interpolación para lograr un sombreado suave.</li>
<li><strong>Sombreado Blinn-Phong</strong>: Una variante del sombreado Phong que es más eficiente para reflejos especulares.</li>
<li><strong>Mapeo de Normales</strong>: Una técnica para agregar detalles a la superficie sin aumentar la complejidad de la geometría.</li>
<li><strong>Mapeo de Paralaje</strong>: Una mejora sobre el mapeo de normales para simular profundidad.</li>
<li><strong>Renderizado Basado en Física (PBR)</strong>: Un método para lograr materiales más realistas simulando las propiedades físicas de las superficies.</li>
</ul>
</div><h1>Sombreado Phong</h1>
<div class='content'><p>El sombreado Phong interpola las normales de la superficie a través de polígonos y calcula los colores de los píxeles basándose en estas normales interpoladas.</p>
</div><h2>Código de Ejemplo</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gVmVydGV4IFNoYWRlcgojdmVyc2lvbiAzMzAgY29yZQpsYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMzIGFQb3M7CmxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzMgYU5vcm1hbDsKCm91dCB2ZWMzIEZyYWdQb3M7Cm91dCB2ZWMzIE5vcm1hbDsKCnVuaWZvcm0gbWF0NCBtb2RlbDsKdW5pZm9ybSBtYXQ0IHZpZXc7CnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uOwoKdm9pZCBtYWluKCkKewogICAgRnJhZ1BvcyA9IHZlYzMobW9kZWwgKiB2ZWM0KGFQb3MsIDEuMCkpOwogICAgTm9ybWFsID0gbWF0Myh0cmFuc3Bvc2UoaW52ZXJzZShtb2RlbCkpKSAqIGFOb3JtYWw7ICAKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZpZXcgKiB2ZWM0KEZyYWdQb3MsIDEuMCk7Cn0KCi8vIEZyYWdtZW50IFNoYWRlcgojdmVyc2lvbiAzMzAgY29yZQpvdXQgdmVjNCBGcmFnQ29sb3I7CgppbiB2ZWMzIEZyYWdQb3M7CmluIHZlYzMgTm9ybWFsOwoKdW5pZm9ybSB2ZWMzIGxpZ2h0UG9zOwp1bmlmb3JtIHZlYzMgdmlld1BvczsKdW5pZm9ybSB2ZWMzIGxpZ2h0Q29sb3I7CnVuaWZvcm0gdmVjMyBvYmplY3RDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIC8vIEFtYmllbnRlCiAgICBmbG9hdCBhbWJpZW50U3RyZW5ndGggPSAwLjE7CiAgICB2ZWMzIGFtYmllbnQgPSBhbWJpZW50U3RyZW5ndGggKiBsaWdodENvbG9yOwogICAgCiAgICAvLyBEaWZ1c28gCiAgICB2ZWMzIG5vcm0gPSBub3JtYWxpemUoTm9ybWFsKTsKICAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUobGlnaHRQb3MgLSBGcmFnUG9zKTsKICAgIGZsb2F0IGRpZmYgPSBtYXgoZG90KG5vcm0sIGxpZ2h0RGlyKSwgMC4wKTsKICAgIHZlYzMgZGlmZnVzZSA9IGRpZmYgKiBsaWdodENvbG9yOwogICAgCiAgICAvLyBFc3BlY3VsYXIKICAgIGZsb2F0IHNwZWN1bGFyU3RyZW5ndGggPSAwLjU7CiAgICB2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUodmlld1BvcyAtIEZyYWdQb3MpOwogICAgdmVjMyByZWZsZWN0RGlyID0gcmVmbGVjdCgtbGlnaHREaXIsIG5vcm0pOyAgCiAgICBmbG9hdCBzcGVjID0gcG93KG1heChkb3Qodmlld0RpciwgcmVmbGVjdERpciksIDAuMCksIDMyKTsKICAgIHZlYzMgc3BlY3VsYXIgPSBzcGVjdWxhclN0cmVuZ3RoICogc3BlYyAqIGxpZ2h0Q29sb3I7ICAKICAgIAogICAgdmVjMyByZXN1bHQgPSAoYW1iaWVudCArIGRpZmZ1c2UgKyBzcGVjdWxhcikgKiBvYmplY3RDb2xvcjsKICAgIEZyYWdDb2xvciA9IHZlYzQocmVzdWx0LCAxLjApOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Vertex Shader
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;  
    gl_Position = projection * view * vec4(FragPos, 1.0);
}

// Fragment Shader
#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    // Ambiente
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Difuso 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Especular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}</pre></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Ambiente</strong>: Una luz constante añadida a todas las superficies para simular iluminación indirecta.</li>
<li><strong>Difuso</strong>: Luz dispersada en muchas direcciones al golpear una superficie rugosa.</li>
<li><strong>Especular</strong>: El punto brillante de luz que aparece en objetos brillantes.</li>
</ul>
</div><h1>Sombreado Blinn-Phong</h1>
<div class='content'><p>El sombreado Blinn-Phong modifica el componente especular para ser más eficiente.</p>
</div><h2>Código de Ejemplo</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRnJhZ21lbnQgU2hhZGVyCiN2ZXJzaW9uIDMzMCBjb3JlCm91dCB2ZWM0IEZyYWdDb2xvcjsKCmluIHZlYzMgRnJhZ1BvczsKaW4gdmVjMyBOb3JtYWw7Cgp1bmlmb3JtIHZlYzMgbGlnaHRQb3M7CnVuaWZvcm0gdmVjMyB2aWV3UG9zOwp1bmlmb3JtIHZlYzMgbGlnaHRDb2xvcjsKdW5pZm9ybSB2ZWMzIG9iamVjdENvbG9yOwoKdm9pZCBtYWluKCkKewogICAgLy8gQW1iaWVudGUKICAgIGZsb2F0IGFtYmllbnRTdHJlbmd0aCA9IDAuMTsKICAgIHZlYzMgYW1iaWVudCA9IGFtYmllbnRTdHJlbmd0aCAqIGxpZ2h0Q29sb3I7CiAgICAKICAgIC8vIERpZnVzbyAKICAgIHZlYzMgbm9ybSA9IG5vcm1hbGl6ZShOb3JtYWwpOwogICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIEZyYWdQb3MpOwogICAgZmxvYXQgZGlmZiA9IG1heChkb3Qobm9ybSwgbGlnaHREaXIpLCAwLjApOwogICAgdmVjMyBkaWZmdXNlID0gZGlmZiAqIGxpZ2h0Q29sb3I7CiAgICAKICAgIC8vIEVzcGVjdWxhcgogICAgZmxvYXQgc3BlY3VsYXJTdHJlbmd0aCA9IDAuNTsKICAgIHZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSh2aWV3UG9zIC0gRnJhZ1Bvcyk7CiAgICB2ZWMzIGhhbGZ3YXlEaXIgPSBub3JtYWxpemUobGlnaHREaXIgKyB2aWV3RGlyKTsgIAogICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KG5vcm0sIGhhbGZ3YXlEaXIpLCAwLjApLCAzMik7CiAgICB2ZWMzIHNwZWN1bGFyID0gc3BlY3VsYXJTdHJlbmd0aCAqIHNwZWMgKiBsaWdodENvbG9yOyAgCiAgICAKICAgIHZlYzMgcmVzdWx0ID0gKGFtYmllbnQgKyBkaWZmdXNlICsgc3BlY3VsYXIpICogb2JqZWN0Q29sb3I7CiAgICBGcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgMS4wKTsKfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Fragment Shader
#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    // Ambiente
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Difuso 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Especular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    float spec = pow(max(dot(norm, halfwayDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}</pre></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Vector Medio</strong>: Usado en lugar del vector de reflexión para calcular el componente especular, mejorando el rendimiento.</li>
</ul>
</div><h1>Mapeo de Normales</h1>
<div class='content'><p>El mapeo de normales agrega detalles a las superficies perturbando las normales.</p>
</div><h2>Código de Ejemplo</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gVmVydGV4IFNoYWRlcgojdmVyc2lvbiAzMzAgY29yZQpsYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMzIGFQb3M7CmxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzMgYU5vcm1hbDsKbGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiBhVGV4Q29vcmRzOwpsYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWMzIGFUYW5nZW50OwpsYXlvdXQobG9jYXRpb24gPSA0KSBpbiB2ZWMzIGFCaXRhbmdlbnQ7CgpvdXQgdmVjMiBUZXhDb29yZHM7Cm91dCB2ZWMzIEZyYWdQb3M7Cm91dCBtYXQzIFRCTjsKCnVuaWZvcm0gbWF0NCBtb2RlbDsKdW5pZm9ybSBtYXQ0IHZpZXc7CnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uOwoKdm9pZCBtYWluKCkKewogICAgRnJhZ1BvcyA9IHZlYzMobW9kZWwgKiB2ZWM0KGFQb3MsIDEuMCkpOwogICAgVGV4Q29vcmRzID0gYVRleENvb3JkczsKICAgIAogICAgbWF0MyBub3JtYWxNYXRyaXggPSB0cmFuc3Bvc2UoaW52ZXJzZShtYXQzKG1vZGVsKSkpOwogICAgdmVjMyBUID0gbm9ybWFsaXplKG5vcm1hbE1hdHJpeCAqIGFUYW5nZW50KTsKICAgIHZlYzMgQiA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBhQml0YW5nZW50KTsKICAgIHZlYzMgTiA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBhTm9ybWFsKTsKICAgIFRCTiA9IG1hdDMoVCwgQiwgTik7CiAgICAKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZpZXcgKiB2ZWM0KEZyYWdQb3MsIDEuMCk7Cn0KCi8vIEZyYWdtZW50IFNoYWRlcgojdmVyc2lvbiAzMzAgY29yZQpvdXQgdmVjNCBGcmFnQ29sb3I7CgppbiB2ZWMyIFRleENvb3JkczsKaW4gdmVjMyBGcmFnUG9zOwppbiBtYXQzIFRCTjsKCnVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDsKdW5pZm9ybSB2ZWMzIGxpZ2h0UG9zOwp1bmlmb3JtIHZlYzMgdmlld1BvczsKdW5pZm9ybSB2ZWMzIGxpZ2h0Q29sb3I7CnVuaWZvcm0gdmVjMyBvYmplY3RDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIHZlYzMgbm9ybWFsID0gdGV4dHVyZShub3JtYWxNYXAsIFRleENvb3JkcykucmdiOwogICAgbm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbCAqIDIuMCAtIDEuMCk7ICAgCiAgICBub3JtYWwgPSBub3JtYWxpemUoVEJOICogbm9ybWFsKTsgIAogICAgCiAgICAvLyBBbWJpZW50ZQogICAgZmxvYXQgYW1iaWVudFN0cmVuZ3RoID0gMC4xOwogICAgdmVjMyBhbWJpZW50ID0gYW1iaWVudFN0cmVuZ3RoICogbGlnaHRDb2xvcjsKICAgIAogICAgLy8gRGlmdXNvIAogICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIEZyYWdQb3MpOwogICAgZmxvYXQgZGlmZiA9IG1heChkb3Qobm9ybWFsLCBsaWdodERpciksIDAuMCk7CiAgICB2ZWMzIGRpZmZ1c2UgPSBkaWZmICogbGlnaHRDb2xvcjsKICAgIAogICAgLy8gRXNwZWN1bGFyCiAgICBmbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMC41OwogICAgdmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKHZpZXdQb3MgLSBGcmFnUG9zKTsKICAgIHZlYzMgcmVmbGVjdERpciA9IHJlZmxlY3QoLWxpZ2h0RGlyLCBub3JtYWwpOyAgCiAgICBmbG9hdCBzcGVjID0gcG93KG1heChkb3Qodmlld0RpciwgcmVmbGVjdERpciksIDAuMCksIDMyKTsKICAgIHZlYzMgc3BlY3VsYXIgPSBzcGVjdWxhclN0cmVuZ3RoICogc3BlYyAqIGxpZ2h0Q29sb3I7ICAKICAgIAogICAgdmVjMyByZXN1bHQgPSAoYW1iaWVudCArIGRpZmZ1c2UgKyBzcGVjdWxhcikgKiBvYmplY3RDb2xvcjsKICAgIEZyYWdDb2xvciA9IHZlYzQocmVzdWx0LCAxLjApOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Vertex Shader
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoords;
layout(location = 3) in vec3 aTangent;
layout(location = 4) in vec3 aBitangent;

out vec2 TexCoords;
out vec3 FragPos;
out mat3 TBN;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    TexCoords = aTexCoords;
    
    mat3 normalMatrix = transpose(inverse(mat3(model)));
    vec3 T = normalize(normalMatrix * aTangent);
    vec3 B = normalize(normalMatrix * aBitangent);
    vec3 N = normalize(normalMatrix * aNormal);
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * vec4(FragPos, 1.0);
}

// Fragment Shader
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;
in vec3 FragPos;
in mat3 TBN;

uniform sampler2D normalMap;
uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    vec3 normal = texture(normalMap, TexCoords).rgb;
    normal = normalize(normal * 2.0 - 1.0);   
    normal = normalize(TBN * normal);  
    
    // Ambiente
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Difuso 
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Especular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, normal);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}</pre></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Matriz TBN</strong>: Transforma las normales del espacio tangente al espacio mundial.</li>
<li><strong>Mapa de Normales</strong>: Una textura que almacena vectores normales.</li>
</ul>
</div><h1>Mapeo de Paralaje</h1>
<div class='content'><p>El mapeo de paralaje simula profundidad desplazando las coordenadas de textura.</p>
</div><h2>Código de Ejemplo</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRnJhZ21lbnQgU2hhZGVyCiN2ZXJzaW9uIDMzMCBjb3JlCm91dCB2ZWM0IEZyYWdDb2xvcjsKCmluIHZlYzIgVGV4Q29vcmRzOwppbiB2ZWMzIEZyYWdQb3M7CmluIG1hdDMgVEJOOwoKdW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwOwp1bmlmb3JtIHNhbXBsZXIyRCBoZWlnaHRNYXA7CnVuaWZvcm0gdmVjMyBsaWdodFBvczsKdW5pZm9ybSB2ZWMzIHZpZXdQb3M7CnVuaWZvcm0gdmVjMyBsaWdodENvbG9yOwp1bmlmb3JtIHZlYzMgb2JqZWN0Q29sb3I7Cgp2ZWMyIFBhcmFsbGF4TWFwcGluZyh2ZWMyIHRleENvb3JkcywgdmVjMyB2aWV3RGlyKQp7CiAgICBmbG9hdCBoZWlnaHQgPSB0ZXh0dXJlKGhlaWdodE1hcCwgdGV4Q29vcmRzKS5yOyAgICAKICAgIGZsb2F0IHNjYWxlID0gMC4xOyAvLyBBanVzdGEgZXN0ZSB2YWxvciBwYXJhIGNvbnRyb2xhciBlbCBlZmVjdG8gZGUgcHJvZnVuZGlkYWQKICAgIHZlYzIgcCA9IHZpZXdEaXIueHkgKiAoaGVpZ2h0ICogc2NhbGUpOwogICAgcmV0dXJuIHRleENvb3JkcyAtIHA7Cn0KCnZvaWQgbWFpbigpCnsKICAgIHZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZShUQk4gKiAodmlld1BvcyAtIEZyYWdQb3MpKTsKICAgIHZlYzIgdGV4Q29vcmRzID0gUGFyYWxsYXhNYXBwaW5nKFRleENvb3Jkcywgdmlld0Rpcik7CiAgICAKICAgIHZlYzMgbm9ybWFsID0gdGV4dHVyZShub3JtYWxNYXAsIHRleENvb3JkcykucmdiOwogICAgbm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbCAqIDIuMCAtIDEuMCk7ICAgCiAgICBub3JtYWwgPSBub3JtYWxpemUoVEJOICogbm9ybWFsKTsgIAogICAgCiAgICAvLyBBbWJpZW50ZQogICAgZmxvYXQgYW1iaWVudFN0cmVuZ3RoID0gMC4xOwogICAgdmVjMyBhbWJpZW50ID0gYW1iaWVudFN0cmVuZ3RoICogbGlnaHRDb2xvcjsKICAgIAogICAgLy8gRGlmdXNvIAogICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIEZyYWdQb3MpOwogICAgZmxvYXQgZGlmZiA9IG1heChkb3Qobm9ybWFsLCBsaWdodERpciksIDAuMCk7CiAgICB2ZWMzIGRpZmZ1c2UgPSBkaWZmICogbGlnaHRDb2xvcjsKICAgIAogICAgLy8gRXNwZWN1bGFyCiAgICBmbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMC41OwogICAgdmVjMyByZWZsZWN0RGlyID0gcmVmbGVjdCgtbGlnaHREaXIsIG5vcm1hbCk7ICAKICAgIGZsb2F0IHNwZWMgPSBwb3cobWF4KGRvdCh2aWV3RGlyLCByZWZsZWN0RGlyKSwgMC4wKSwgMzIpOwogICAgdmVjMyBzcGVjdWxhciA9IHNwZWN1bGFyU3RyZW5ndGggKiBzcGVjICogbGlnaHRDb2xvcjsgIAogICAgCiAgICB2ZWMzIHJlc3VsdCA9IChhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyKSAqIG9iamVjdENvbG9yOwogICAgRnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsIDEuMCk7Cn0="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Fragment Shader
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;
in vec3 FragPos;
in mat3 TBN;

uniform sampler2D normalMap;
uniform sampler2D heightMap;
uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir)
{
    float height = texture(heightMap, texCoords).r;    
    float scale = 0.1; // Ajusta este valor para controlar el efecto de profundidad
    vec2 p = viewDir.xy * (height * scale);
    return texCoords - p;
}

void main()
{
    vec3 viewDir = normalize(TBN * (viewPos - FragPos));
    vec2 texCoords = ParallaxMapping(TexCoords, viewDir);
    
    vec3 normal = texture(normalMap, texCoords).rgb;
    normal = normalize(normal * 2.0 - 1.0);   
    normal = normalize(TBN * normal);  
    
    // Ambiente
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Difuso 
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Especular
    float specularStrength = 0.5;
    vec3 reflectDir = reflect(-lightDir, normal);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}</pre></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Mapa de Altura</strong>: Una textura que almacena información de altura.</li>
<li><strong>Función de Mapeo de Paralaje</strong>: Ajusta las coordenadas de textura basándose en la dirección de vista y la altura.</li>
</ul>
</div><h1>Renderizado Basado en Física (PBR)</h1>
<div class='content'><p>El PBR busca lograr un renderizado más realista simulando las propiedades físicas de los materiales.</p>
</div><h2>Componentes Clave</h2>
<div class='content'><ul>
<li><strong>Albedo</strong>: Color base del material.</li>
<li><strong>Metálico</strong>: Determina si el material es metálico.</li>
<li><strong>Rugosidad</strong>: Controla la suavidad de la superficie.</li>
<li><strong>Oclusión Ambiental</strong>: Simula sombras en las grietas.</li>
</ul>
</div><h2>Código de Ejemplo</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gRnJhZ21lbnQgU2hhZGVyCiN2ZXJzaW9uIDMzMCBjb3JlCm91dCB2ZWM0IEZyYWdDb2xvcjsKCmluIHZlYzIgVGV4Q29vcmRzOwppbiB2ZWMzIEZyYWdQb3M7CmluIHZlYzMgTm9ybWFsOwoKdW5pZm9ybSBzYW1wbGVyMkQgYWxiZWRvTWFwOwp1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbGxpY01hcDsKdW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwOwp1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDsKdW5pZm9ybSB2ZWMzIGxpZ2h0UG9zOwp1bmlmb3JtIHZlYzMgdmlld1BvczsKCmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1OTsKCnZlYzMgZnJlc25lbFNjaGxpY2soZmxvYXQgY29zVGhldGEsIHZlYzMgRjApCnsKICAgIHJldHVybiBGMCArICgxLjAgLSBGMCkgKiBwb3coMS4wIC0gY29zVGhldGEsIDUuMCk7Cn0KCnZvaWQgbWFpbigpCnsKICAgIHZlYzMgYWxiZWRvID0gdGV4dHVyZShhbGJlZG9NYXAsIFRleENvb3JkcykucmdiOwogICAgZmxvYXQgbWV0YWxsaWMgPSB0ZXh0dXJlKG1ldGFsbGljTWFwLCBUZXhDb29yZHMpLnI7CiAgICBmbG9hdCByb3VnaG5lc3MgPSB0ZXh0dXJlKHJvdWdobmVzc01hcCwgVGV4Q29vcmRzKS5yOwogICAgZmxvYXQgYW8gPSB0ZXh0dXJlKGFvTWFwLCBUZXhDb29yZHMpLnI7CiAgICAKICAgIHZlYzMgTiA9IG5vcm1hbGl6ZShOb3JtYWwpOwogICAgdmVjMyBWID0gbm9ybWFsaXplKHZpZXdQb3MgLSBGcmFnUG9zKTsKICAgIHZlYzMgTCA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIEZyYWdQb3MpOwogICAgdmVjMyBIID0gbm9ybWFsaXplKFYgKyBMKTsKICAgIAogICAgdmVjMyBGMCA9IHZlYzMoMC4wNCk7IAogICAgRjAgPSBtaXgoRjAsIGFsYmVkbywgbWV0YWxsaWMpOwogICAgCiAgICB2ZWMzIEYgPSBmcmVzbmVsU2NobGljayhtYXgoZG90KEgsIFYpLCAwLjApLCBGMCk7CiAgICBmbG9hdCBOREYgPSBEaXN0cmlidXRpb25HR1goTiwgSCwgcm91Z2huZXNzKTsKICAgIGZsb2F0IEcgPSBHZW9tZXRyeVNtaXRoKE4sIFYsIEwsIHJvdWdobmVzcyk7CiAgICAKICAgIHZlYzMgbnVtZXJhdG9yID0gTkRGICogRyAqIEY7CiAgICBmbG9hdCBkZW5vbWluYXRvciA9IDQuMCAqIG1heChkb3QoTiwgViksIDAuMCkgKiBtYXgoZG90KE4sIEwpLCAwLjApICsgMC4wMDE7CiAgICB2ZWMzIHNwZWN1bGFyID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7CiAgICAKICAgIHZlYzMga1MgPSBGOwogICAgdmVjMyBrRCA9IHZlYzMoMS4wKSAtIGtTOwogICAga0QgKj0gMS4wIC0gbWV0YWxsaWM7CiAgICAKICAgIGZsb2F0IE5kb3RMID0gbWF4KGRvdChOLCBMKSwgMC4wKTsKICAgIHZlYzMgTG8gPSAoa0QgKiBhbGJlZG8gLyBQSSArIHNwZWN1bGFyKSAqIGxpZ2h0Q29sb3IgKiBOZG90TDsKICAgIAogICAgdmVjMyBhbWJpZW50ID0gdmVjMygwLjAzKSAqIGFsYmVkbyAqIGFvOwogICAgdmVjMyBjb2xvciA9IGFtYmllbnQgKyBMbzsKICAgIAogICAgRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTsKfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Fragment Shader
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;
in vec3 FragPos;
in vec3 Normal;

uniform sampler2D albedoMap;
uniform sampler2D metallicMap;
uniform sampler2D roughnessMap;
uniform sampler2D aoMap;
uniform vec3 lightPos;
uniform vec3 viewPos;

const float PI = 3.14159265359;

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

void main()
{
    vec3 albedo = texture(albedoMap, TexCoords).rgb;
    float metallic = texture(metallicMap, TexCoords).r;
    float roughness = texture(roughnessMap, TexCoords).r;
    float ao = texture(aoMap, TexCoords).r;
    
    vec3 N = normalize(Normal);
    vec3 V = normalize(viewPos - FragPos);
    vec3 L = normalize(lightPos - FragPos);
    vec3 H = normalize(V + L);
    
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    float NDF = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    
    vec3 numerator = NDF * G * F;
    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;
    vec3 specular = numerator / denominator;
    
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    
    float NdotL = max(dot(N, L), 0.0);
    vec3 Lo = (kD * albedo / PI + specular) * lightColor * NdotL;
    
    vec3 ambient = vec3(0.03) * albedo * ao;
    vec3 color = ambient + Lo;
    
    FragColor = vec4(color, 1.0);
}</pre></div><h2>Explicación</h2>
<div class='content'><ul>
<li><strong>Aproximación Fresnel-Schlick</strong>: Calcula la reflexión en diferentes ángulos.</li>
<li><strong>Distribución GGX</strong>: Determina la distribución de microfacetas.</li>
<li><strong>Geometría Smith</strong>: Modela el sombreado y enmascaramiento de microfacetas.</li>
</ul>
</div><h1>Conclusión</h1>
<div class='content'><p>Las técnicas avanzadas de sombreado en OpenGL, como el Sombreado Phong, Sombreado Blinn-Phong, Mapeo de Normales, Mapeo de Paralaje y Renderizado Basado en Física, permiten la creación de gráficos altamente realistas y detallados. Comprender e implementar estas técnicas puede mejorar significativamente la calidad visual de tus aplicaciones. Al dominar estos métodos avanzados de sombreado, puedes empujar los límites de lo que es posible en el renderizado en tiempo real.</p>
</div><div class='row navigation'>
	<div class='col-4'>
					<a href='framebuffers-and-renderbuffers'>&#x25C4;Framebuffers y Renderbuffers</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Técnicas Avanzadas de Sombreado</a>
	</div>
	<div class='col-4 text-end'>
					<a href='shadow-mapping'>Mapeo de Sombras &#x25BA;</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Aceptar</a>
    <a href="/cookies">Mas información</a>
</div>	

	</div>    
</body>
</html>
