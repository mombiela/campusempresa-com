<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validación y Pruebas</title>

    <link rel="alternate" href="https://campusempresa.com/mod/pytorch/03-03-validation-testing" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/pytorch/03-03-validation-testing" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/pytorch/03-03-validation-testing" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="/js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-12 col-md-8 p-2 p-md-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-12 col-md-4 p-2 p-md-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-2 p-md-0 m-0 text-end">
										<a href="https://enterprisecampus.net/mod/pytorch/03-03-validation-testing" class="px-2">EN</a></b>
				|
				<b class="px-2">ES</b>
				|
				<a href="https://campusempresa.cat/mod/pytorch/03-03-validation-testing" class="px-2">CA</a>
								</div>
	</div>
</div>

<div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<!-- <a href="/">Home</a>  -->
									<a href="./">Contenido del curso</a>
					<span class="sep">|</span>
								<a href="/all/competencias">Competencias técnicas</a>
				<a href="/all/conocimientos">Conocimientos</a>
				<a href="/all/soft_skills">Competencias sociales</a>
			</div>
		</div>
	</div>
</div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
								<div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='03-02-training-loop' title="Bucle de Entrenamiento">
				<span class="d-none d-md-inline">&#x25C4; Anterior</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
					<a href="./"><h2 style="text-decoration:underline">Validación y Pruebas</h2></a>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='03-04-saving-loading-models' title="Guardar y Cargar Modelos">
				<span class="d-none d-md-inline">Siguiente &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>
<div class='content'><p>En este módulo, aprenderemos cómo validar y probar nuestras redes neuronales entrenadas. La validación y las pruebas son pasos cruciales en el desarrollo de modelos de aprendizaje profundo, ya que nos permiten evaluar el rendimiento del modelo y asegurarnos de que no esté sobreajustado a los datos de entrenamiento.</p>
</div><h1><p>Objetivos del Módulo</p>
</h1>
<div class='content'><ul>
<li>Comprender la diferencia entre validación y pruebas.</li>
<li>Implementar un bucle de validación.</li>
<li>Evaluar el rendimiento del modelo en un conjunto de pruebas.</li>
<li>Interpretar métricas de rendimiento.</li>
</ul>
</div><h1><p>Contenido</p>
</h1>
<div class='content'><ol>
<li><a href="#diferencia-entre-validación-y-pruebas">Diferencia entre Validación y Pruebas</a></li>
<li><a href="#implementación-del-bucle-de-validación">Implementación del Bucle de Validación</a></li>
<li><a href="#evaluación-del-modelo-en-el-conjunto-de-pruebas">Evaluación del Modelo en el Conjunto de Pruebas</a></li>
<li><a href="#interpretación-de-métricas-de-rendimiento">Interpretación de Métricas de Rendimiento</a></li>
<li><a href="#ejercicio-práctico">Ejercicio Práctico</a></li>
<li><a href="#conclusión">Conclusión</a></li>
</ol>
</div><h1><p>Diferencia entre Validación y Pruebas</p>
</h1>
<div class='content'></div><h2><p>Validación</p>
</h2>
<div class='content'><ul>
<li><strong>Propósito</strong>: Ajustar hiperparámetros y evitar el sobreajuste.</li>
<li><strong>Conjunto de Datos</strong>: Subconjunto del conjunto de entrenamiento.</li>
<li><strong>Frecuencia</strong>: Durante el entrenamiento, después de cada época o cada cierto número de iteraciones.</li>
</ul>
</div><h2><p>Pruebas</p>
</h2>
<div class='content'><ul>
<li><strong>Propósito</strong>: Evaluar el rendimiento final del modelo.</li>
<li><strong>Conjunto de Datos</strong>: Conjunto de datos completamente separado que no se ha utilizado durante el entrenamiento o la validación.</li>
<li><strong>Frecuencia</strong>: Una vez, después de que el modelo ha sido completamente entrenado.</li>
</ul>
</div><h1><p>Implementación del Bucle de Validación</p>
</h1>
<div class='content'><p>El bucle de validación es similar al bucle de entrenamiento, pero sin la actualización de los pesos del modelo. Aquí hay un ejemplo de cómo implementar un bucle de validación en PyTorch:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IHRvcmNoCmltcG9ydCB0b3JjaC5ubiBhcyBubgppbXBvcnQgdG9yY2gub3B0aW0gYXMgb3B0aW0KZnJvbSB0b3JjaC51dGlscy5kYXRhIGltcG9ydCBEYXRhTG9hZGVyCgojIFN1cG9uZ2Ftb3MgcXVlIHlhIHRlbmVtb3MgdW4gbW9kZWxvLCB1biBjb25qdW50byBkZSBkYXRvcyBkZSB2YWxpZGFjacOzbiB5IHVuIERhdGFMb2FkZXIKbW9kZWwgPSAuLi4gICMgVHUgbW9kZWxvCnZhbGlkYXRpb25fbG9hZGVyID0gRGF0YUxvYWRlcih2YWxpZGF0aW9uX2RhdGFzZXQsIGJhdGNoX3NpemU9MzIsIHNodWZmbGU9RmFsc2UpCmNyaXRlcmlvbiA9IG5uLkNyb3NzRW50cm9weUxvc3MoKQoKZGVmIHZhbGlkYXRlKG1vZGVsLCB2YWxpZGF0aW9uX2xvYWRlciwgY3JpdGVyaW9uKToKICAgIG1vZGVsLmV2YWwoKSAgIyBQb25lciBlbCBtb2RlbG8gZW4gbW9kbyBkZSBldmFsdWFjacOzbgogICAgdmFsaWRhdGlvbl9sb3NzID0gMC4wCiAgICBjb3JyZWN0ID0gMAogICAgdG90YWwgPSAwCgogICAgd2l0aCB0b3JjaC5ub19ncmFkKCk6ICAjIE5vIG5lY2VzaXRhbW9zIGNhbGN1bGFyIGdyYWRpZW50ZXMgcGFyYSBsYSB2YWxpZGFjacOzbgogICAgICAgIGZvciBpbnB1dHMsIGxhYmVscyBpbiB2YWxpZGF0aW9uX2xvYWRlcjoKICAgICAgICAgICAgb3V0cHV0cyA9IG1vZGVsKGlucHV0cykKICAgICAgICAgICAgbG9zcyA9IGNyaXRlcmlvbihvdXRwdXRzLCBsYWJlbHMpCiAgICAgICAgICAgIHZhbGlkYXRpb25fbG9zcyArPSBsb3NzLml0ZW0oKQogICAgICAgICAgICAKICAgICAgICAgICAgXywgcHJlZGljdGVkID0gdG9yY2gubWF4KG91dHB1dHMsIDEpCiAgICAgICAgICAgIHRvdGFsICs9IGxhYmVscy5zaXplKDApCiAgICAgICAgICAgIGNvcnJlY3QgKz0gKHByZWRpY3RlZCA9PSBsYWJlbHMpLnN1bSgpLml0ZW0oKQoKICAgIGFjY3VyYWN5ID0gMTAwICogY29ycmVjdCAvIHRvdGFsCiAgICBhdmVyYWdlX2xvc3MgPSB2YWxpZGF0aW9uX2xvc3MgLyBsZW4odmFsaWRhdGlvbl9sb2FkZXIpCiAgICAKICAgIHJldHVybiBhdmVyYWdlX2xvc3MsIGFjY3VyYWN5CgojIEVqZW1wbG8gZGUgdXNvCnZhbF9sb3NzLCB2YWxfYWNjdXJhY3kgPSB2YWxpZGF0ZShtb2RlbCwgdmFsaWRhdGlvbl9sb2FkZXIsIGNyaXRlcmlvbikKcHJpbnQoZidWYWxpZGF0aW9uIExvc3M6IHt2YWxfbG9zczouNGZ9LCBWYWxpZGF0aW9uIEFjY3VyYWN5OiB7dmFsX2FjY3VyYWN5Oi4yZn0lJyk="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader

# Supongamos que ya tenemos un modelo, un conjunto de datos de validaci&oacute;n y un DataLoader
model = ...  # Tu modelo
validation_loader = DataLoader(validation_dataset, batch_size=32, shuffle=False)
criterion = nn.CrossEntropyLoss()

def validate(model, validation_loader, criterion):
    model.eval()  # Poner el modelo en modo de evaluaci&oacute;n
    validation_loss = 0.0
    correct = 0
    total = 0

    with torch.no_grad():  # No necesitamos calcular gradientes para la validaci&oacute;n
        for inputs, labels in validation_loader:
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            validation_loss += loss.item()
            
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    accuracy = 100 * correct / total
    average_loss = validation_loss / len(validation_loader)
    
    return average_loss, accuracy

# Ejemplo de uso
val_loss, val_accuracy = validate(model, validation_loader, criterion)
print(f'Validation Loss: {val_loss:.4f}, Validation Accuracy: {val_accuracy:.2f}%')</pre></div><div class='content'></div><h2><p>Explicación del Código</p>
</h2>
<div class='content'><ul>
<li><code>model.eval()</code>: Pone el modelo en modo de evaluación, desactivando el dropout y otras capas que se comportan de manera diferente durante el entrenamiento.</li>
<li><code>with torch.no_grad()</code>: Desactiva el cálculo de gradientes, lo que reduce el uso de memoria y acelera la validación.</li>
<li><code>validation_loss += loss.item()</code>: Acumula la pérdida de validación.</li>
<li><code>_, predicted = torch.max(outputs, 1)</code>: Obtiene las predicciones del modelo.</li>
<li><code>correct += (predicted == labels).sum().item()</code>: Cuenta el número de predicciones correctas.</li>
<li><code>accuracy = 100 * correct / total</code>: Calcula la precisión del modelo.</li>
</ul>
</div><h1><p>Evaluación del Modelo en el Conjunto de Pruebas</p>
</h1>
<div class='content'><p>Una vez que el modelo ha sido entrenado y validado, es hora de evaluar su rendimiento en el conjunto de pruebas. Este proceso es similar al de validación, pero se realiza una sola vez y utiliza un conjunto de datos completamente separado.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("dGVzdF9sb2FkZXIgPSBEYXRhTG9hZGVyKHRlc3RfZGF0YXNldCwgYmF0Y2hfc2l6ZT0zMiwgc2h1ZmZsZT1GYWxzZSkKCmRlZiB0ZXN0KG1vZGVsLCB0ZXN0X2xvYWRlciwgY3JpdGVyaW9uKToKICAgIG1vZGVsLmV2YWwoKQogICAgdGVzdF9sb3NzID0gMC4wCiAgICBjb3JyZWN0ID0gMAogICAgdG90YWwgPSAwCgogICAgd2l0aCB0b3JjaC5ub19ncmFkKCk6CiAgICAgICAgZm9yIGlucHV0cywgbGFiZWxzIGluIHRlc3RfbG9hZGVyOgogICAgICAgICAgICBvdXRwdXRzID0gbW9kZWwoaW5wdXRzKQogICAgICAgICAgICBsb3NzID0gY3JpdGVyaW9uKG91dHB1dHMsIGxhYmVscykKICAgICAgICAgICAgdGVzdF9sb3NzICs9IGxvc3MuaXRlbSgpCiAgICAgICAgICAgIAogICAgICAgICAgICBfLCBwcmVkaWN0ZWQgPSB0b3JjaC5tYXgob3V0cHV0cywgMSkKICAgICAgICAgICAgdG90YWwgKz0gbGFiZWxzLnNpemUoMCkKICAgICAgICAgICAgY29ycmVjdCArPSAocHJlZGljdGVkID09IGxhYmVscykuc3VtKCkuaXRlbSgpCgogICAgYWNjdXJhY3kgPSAxMDAgKiBjb3JyZWN0IC8gdG90YWwKICAgIGF2ZXJhZ2VfbG9zcyA9IHRlc3RfbG9zcyAvIGxlbih0ZXN0X2xvYWRlcikKICAgIAogICAgcmV0dXJuIGF2ZXJhZ2VfbG9zcywgYWNjdXJhY3kKCiMgRWplbXBsbyBkZSB1c28KdGVzdF9sb3NzLCB0ZXN0X2FjY3VyYWN5ID0gdGVzdChtb2RlbCwgdGVzdF9sb2FkZXIsIGNyaXRlcmlvbikKcHJpbnQoZidUZXN0IExvc3M6IHt0ZXN0X2xvc3M6LjRmfSwgVGVzdCBBY2N1cmFjeToge3Rlc3RfYWNjdXJhY3k6LjJmfSUnKQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

def test(model, test_loader, criterion):
    model.eval()
    test_loss = 0.0
    correct = 0
    total = 0

    with torch.no_grad():
        for inputs, labels in test_loader:
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            test_loss += loss.item()
            
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    accuracy = 100 * correct / total
    average_loss = test_loss / len(test_loader)
    
    return average_loss, accuracy

# Ejemplo de uso
test_loss, test_accuracy = test(model, test_loader, criterion)
print(f'Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.2f}%')</pre></div><div class='content'></div><h1><p>Interpretación de Métricas de Rendimiento</p>
</h1>
<div class='content'></div><h2><p>Pérdida (Loss)</p>
</h2>
<div class='content'><ul>
<li><strong>Definición</strong>: Mide cuán bien o mal el modelo está haciendo en términos de su objetivo de optimización.</li>
<li><strong>Interpretación</strong>: Un valor de pérdida más bajo indica un mejor rendimiento del modelo.</li>
</ul>
</div><h2><p>Precisión (Accuracy)</p>
</h2>
<div class='content'><ul>
<li><strong>Definición</strong>: Proporción de predicciones correctas sobre el total de predicciones.</li>
<li><strong>Interpretación</strong>: Una precisión más alta indica un mejor rendimiento del modelo.</li>
</ul>
</div><h2><p>Otras Métricas</p>
</h2>
<div class='content'><ul>
<li><strong>Precisión (Precision)</strong>: Proporción de verdaderos positivos sobre el total de positivos predichos.</li>
<li><strong>Recuperación (Recall)</strong>: Proporción de verdaderos positivos sobre el total de positivos reales.</li>
<li><strong>F1-Score</strong>: Media armónica de precisión y recuperación.</li>
</ul>
</div><h1><p>Ejercicio Práctico</p>
</h1>
<div class='content'></div><h2><p>Ejercicio</p>
</h2>
<div class='content'><ol>
<li>Implementa un bucle de validación y pruebas para un modelo de red neuronal simple.</li>
<li>Entrena el modelo en un conjunto de datos de entrenamiento.</li>
<li>Valida el modelo después de cada época.</li>
<li>Evalúa el modelo en el conjunto de pruebas después del entrenamiento.</li>
</ol>
</div><h2><p>Solución</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IHRvcmNoCmltcG9ydCB0b3JjaC5ubiBhcyBubgppbXBvcnQgdG9yY2gub3B0aW0gYXMgb3B0aW0KZnJvbSB0b3JjaC51dGlscy5kYXRhIGltcG9ydCBEYXRhTG9hZGVyLCByYW5kb21fc3BsaXQKZnJvbSB0b3JjaHZpc2lvbiBpbXBvcnQgZGF0YXNldHMsIHRyYW5zZm9ybXMKCiMgRGVmaW5pciB0cmFuc2Zvcm1hY2lvbmVzCnRyYW5zZm9ybSA9IHRyYW5zZm9ybXMuQ29tcG9zZShbdHJhbnNmb3Jtcy5Ub1RlbnNvcigpLCB0cmFuc2Zvcm1zLk5vcm1hbGl6ZSgoMC41LCksICgwLjUsKSldKQoKIyBEZXNjYXJnYXIgeSBjYXJnYXIgZWwgY29uanVudG8gZGUgZGF0b3MKZGF0YXNldCA9IGRhdGFzZXRzLk1OSVNUKHJvb3Q9Jy4vZGF0YScsIHRyYWluPVRydWUsIGRvd25sb2FkPVRydWUsIHRyYW5zZm9ybT10cmFuc2Zvcm0pCnRyYWluX2RhdGFzZXQsIHZhbF9kYXRhc2V0ID0gcmFuZG9tX3NwbGl0KGRhdGFzZXQsIFs1MDAwMCwgMTAwMDBdKQp0ZXN0X2RhdGFzZXQgPSBkYXRhc2V0cy5NTklTVChyb290PScuL2RhdGEnLCB0cmFpbj1GYWxzZSwgZG93bmxvYWQ9VHJ1ZSwgdHJhbnNmb3JtPXRyYW5zZm9ybSkKCnRyYWluX2xvYWRlciA9IERhdGFMb2FkZXIodHJhaW5fZGF0YXNldCwgYmF0Y2hfc2l6ZT0zMiwgc2h1ZmZsZT1UcnVlKQp2YWxfbG9hZGVyID0gRGF0YUxvYWRlcih2YWxfZGF0YXNldCwgYmF0Y2hfc2l6ZT0zMiwgc2h1ZmZsZT1GYWxzZSkKdGVzdF9sb2FkZXIgPSBEYXRhTG9hZGVyKHRlc3RfZGF0YXNldCwgYmF0Y2hfc2l6ZT0zMiwgc2h1ZmZsZT1GYWxzZSkKCiMgRGVmaW5pciBlbCBtb2RlbG8KY2xhc3MgU2ltcGxlTk4obm4uTW9kdWxlKToKICAgIGRlZiBfX2luaXRfXyhzZWxmKToKICAgICAgICBzdXBlcihTaW1wbGVOTiwgc2VsZikuX19pbml0X18oKQogICAgICAgIHNlbGYuZmMxID0gbm4uTGluZWFyKDI4KjI4LCAxMjgpCiAgICAgICAgc2VsZi5mYzIgPSBubi5MaW5lYXIoMTI4LCAxMCkKCiAgICBkZWYgZm9yd2FyZChzZWxmLCB4KToKICAgICAgICB4ID0geC52aWV3KC0xLCAyOCoyOCkKICAgICAgICB4ID0gdG9yY2gucmVsdShzZWxmLmZjMSh4KSkKICAgICAgICB4ID0gc2VsZi5mYzIoeCkKICAgICAgICByZXR1cm4geAoKbW9kZWwgPSBTaW1wbGVOTigpCmNyaXRlcmlvbiA9IG5uLkNyb3NzRW50cm9weUxvc3MoKQpvcHRpbWl6ZXIgPSBvcHRpbS5TR0QobW9kZWwucGFyYW1ldGVycygpLCBscj0wLjAxKQoKIyBFbnRyZW5hbWllbnRvIHkgdmFsaWRhY2nDs24KbnVtX2Vwb2NocyA9IDEwCmZvciBlcG9jaCBpbiByYW5nZShudW1fZXBvY2hzKToKICAgIG1vZGVsLnRyYWluKCkKICAgIGZvciBpbnB1dHMsIGxhYmVscyBpbiB0cmFpbl9sb2FkZXI6CiAgICAgICAgb3B0aW1pemVyLnplcm9fZ3JhZCgpCiAgICAgICAgb3V0cHV0cyA9IG1vZGVsKGlucHV0cykKICAgICAgICBsb3NzID0gY3JpdGVyaW9uKG91dHB1dHMsIGxhYmVscykKICAgICAgICBsb3NzLmJhY2t3YXJkKCkKICAgICAgICBvcHRpbWl6ZXIuc3RlcCgpCiAgICAKICAgIHZhbF9sb3NzLCB2YWxfYWNjdXJhY3kgPSB2YWxpZGF0ZShtb2RlbCwgdmFsX2xvYWRlciwgY3JpdGVyaW9uKQogICAgcHJpbnQoZidFcG9jaCB7ZXBvY2grMX0ve251bV9lcG9jaHN9LCBWYWxpZGF0aW9uIExvc3M6IHt2YWxfbG9zczouNGZ9LCBWYWxpZGF0aW9uIEFjY3VyYWN5OiB7dmFsX2FjY3VyYWN5Oi4yZn0lJykKCiMgRXZhbHVhY2nDs24gZW4gZWwgY29uanVudG8gZGUgcHJ1ZWJhcwp0ZXN0X2xvc3MsIHRlc3RfYWNjdXJhY3kgPSB0ZXN0KG1vZGVsLCB0ZXN0X2xvYWRlciwgY3JpdGVyaW9uKQpwcmludChmJ1Rlc3QgTG9zczoge3Rlc3RfbG9zczouNGZ9LCBUZXN0IEFjY3VyYWN5OiB7dGVzdF9hY2N1cmFjeTouMmZ9JScp"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, random_split
from torchvision import datasets, transforms

# Definir transformaciones
transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))])

# Descargar y cargar el conjunto de datos
dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)
train_dataset, val_dataset = random_split(dataset, [50000, 10000])
test_dataset = datasets.MNIST(root='./data', train=False, download=True, transform=transform)

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

# Definir el modelo
class SimpleNN(nn.Module):
    def __init__(self):
        super(SimpleNN, self).__init__()
        self.fc1 = nn.Linear(28*28, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = x.view(-1, 28*28)
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x

model = SimpleNN()
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.01)

# Entrenamiento y validaci&oacute;n
num_epochs = 10
for epoch in range(num_epochs):
    model.train()
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
    
    val_loss, val_accuracy = validate(model, val_loader, criterion)
    print(f'Epoch {epoch+1}/{num_epochs}, Validation Loss: {val_loss:.4f}, Validation Accuracy: {val_accuracy:.2f}%')

# Evaluaci&oacute;n en el conjunto de pruebas
test_loss, test_accuracy = test(model, test_loader, criterion)
print(f'Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.2f}%')</pre></div><div class='content'></div><h1><p>Conclusión</p>
</h1>
<div class='content'><p>En esta sección, hemos aprendido la importancia de la validación y las pruebas en el desarrollo de modelos de aprendizaje profundo. Implementamos bucles de validación y pruebas en PyTorch y discutimos cómo interpretar las métricas de rendimiento. Estos pasos son esenciales para asegurarnos de que nuestro modelo generalice bien a datos no vistos y no esté sobreajustado a los datos de entrenamiento.</p>
<p>En el próximo módulo, profundizaremos en las Redes Neuronales Convolucionales (CNNs), una arquitectura poderosa para el procesamiento de datos visuales.</p>
</div><div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='03-02-training-loop' title="Bucle de Entrenamiento">
				<span class="d-none d-md-inline">&#x25C4; Anterior</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='03-04-saving-loading-models' title="Guardar y Cargar Modelos">
				<span class="d-none d-md-inline">Siguiente &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Usamos cookies para mejorar tu experiencia de uso y ofrecer contenidos adaptados a tus intereses.
    <a href="#" id="btn_accept_cookies" class="button">Aceptar</a>
    <a href="/cookies">Mas información</a>
</div>	

	</div>    
</body>
</html>
