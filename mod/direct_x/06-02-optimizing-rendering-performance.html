<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimizando el Rendimiento de Renderizado</title>

    <link rel="alternate" href="https://campusempresa.com/mod/direct_x/06-02-optimizing-rendering-performance" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/direct_x/06-02-optimizing-rendering-performance" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/direct_x/06-02-optimizing-rendering-performance" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="/js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-12 col-md-8 p-2 p-md-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-12 col-md-4 p-2 p-md-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-2 p-md-0 m-0 text-end">
										<a href="https://enterprisecampus.net/mod/direct_x/06-02-optimizing-rendering-performance" class="px-2">EN</a></b>
				|
				<b class="px-2">ES</b>
				|
				<a href="https://campusempresa.cat/mod/direct_x/06-02-optimizing-rendering-performance" class="px-2">CA</a>
								</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">El Proyecto</a>
				<a href="/about">Sobre nosotros</a>
				<a href="/contribute">Contribuir</a>
				<a href="/donate">Donaciones</a>
				<a href="/licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
								<div class='row navigation'>
	<div class='col-2'>
					<a href='06-01-profiling-debugging' title="Perfilado y Depuración">&#x25C4;Anterior</a>
			</div>
	<div class='col-8 text-center'>
					<a href="./"><h2 style="text-decoration:underline">Optimizando el Rendimiento de Renderizado</h2></a>
			</div>
	<div class='col-2 text-end'>
					<a href='06-03-memory-management' title="Gestión de Memoria">Siguiente &#x25BA;</a>
			</div>
</div>
<div class='content'><p>En este módulo, aprenderemos diversas técnicas y estrategias para optimizar el rendimiento de renderizado en aplicaciones DirectX. La optimización es crucial para asegurar que nuestras aplicaciones funcionen de manera eficiente y ofrezcan una experiencia de usuario fluida, especialmente en entornos de gráficos intensivos como los videojuegos.</p>
</div><h1><p>Conceptos Clave</p>
</h1>
<div class='content'><ol>
<li><strong>Batching</strong>: Agrupar múltiples objetos para reducir el número de llamadas de dibujo.</li>
<li><strong>Instancing</strong>: Dibujar múltiples instancias de un objeto con una sola llamada de dibujo.</li>
<li><strong>LOD (Level of Detail)</strong>: Ajustar el nivel de detalle de los modelos en función de su distancia a la cámara.</li>
<li><strong>Culling</strong>: Omitir el renderizado de objetos que no son visibles.</li>
<li><strong>Optimización de Shaders</strong>: Mejorar la eficiencia de los shaders.</li>
<li><strong>Compresión de Texturas</strong>: Reducir el tamaño de las texturas para mejorar el rendimiento.</li>
</ol>
</div><h1><p>Batching</p>
</h1>
<div class='content'><p>Batching es una técnica que agrupa múltiples objetos en una sola llamada de dibujo para reducir la sobrecarga de la CPU. Esto es especialmente útil cuando se renderizan muchos objetos pequeños.</p>
</div><h2><p>Ejemplo de Batching</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gU3Vwb25nYW1vcyBxdWUgdGVuZW1vcyB1biBhcnJheSBkZSB2w6lydGljZXMgcGFyYSBtw7psdGlwbGVzIG9iamV0b3MKc3RkOjp2ZWN0b3I8VmVydGV4PiB2ZXJ0aWNlczsKCi8vIExsZW5hbW9zIGVsIGFycmF5IGNvbiBsb3MgdsOpcnRpY2VzIGRlIHRvZG9zIGxvcyBvYmpldG9zCmZvciAoY29uc3QgYXV0byYgb2JqZWN0IDogb2JqZWN0cykgewogICAgdmVydGljZXMuaW5zZXJ0KHZlcnRpY2VzLmVuZCgpLCBvYmplY3QudmVydGljZXMuYmVnaW4oKSwgb2JqZWN0LnZlcnRpY2VzLmVuZCgpKTsKfQoKLy8gQ3JlYW1vcyB1biBidWZmZXIgZGUgdsOpcnRpY2VzCkQzRDExX0JVRkZFUl9ERVNDIGJ1ZmZlckRlc2MgPSB7fTsKYnVmZmVyRGVzYy5Vc2FnZSA9IEQzRDExX1VTQUdFX0RFRkFVTFQ7CmJ1ZmZlckRlc2MuQnl0ZVdpZHRoID0gc2l6ZW9mKFZlcnRleCkgKiB2ZXJ0aWNlcy5zaXplKCk7CmJ1ZmZlckRlc2MuQmluZEZsYWdzID0gRDNEMTFfQklORF9WRVJURVhfQlVGRkVSOwoKRDNEMTFfU1VCUkVTT1VSQ0VfREFUQSBpbml0RGF0YSA9IHt9Owppbml0RGF0YS5wU3lzTWVtID0gdmVydGljZXMuZGF0YSgpOwoKSUQzRDExQnVmZmVyKiB2ZXJ0ZXhCdWZmZXI7CmRldmljZS0+Q3JlYXRlQnVmZmVyKCZidWZmZXJEZXNjLCAmaW5pdERhdGEsICZ2ZXJ0ZXhCdWZmZXIpOwoKLy8gRGlidWphbW9zIHRvZG9zIGxvcyBvYmpldG9zIGVuIHVuYSBzb2xhIGxsYW1hZGEKVUlOVCBzdHJpZGUgPSBzaXplb2YoVmVydGV4KTsKVUlOVCBvZmZzZXQgPSAwOwpjb250ZXh0LT5JQVNldFZlcnRleEJ1ZmZlcnMoMCwgMSwgJnZlcnRleEJ1ZmZlciwgJnN0cmlkZSwgJm9mZnNldCk7CmNvbnRleHQtPkRyYXcodmVydGljZXMuc2l6ZSgpLCAwKTs="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Supongamos que tenemos un array de v&eacute;rtices para m&uacute;ltiples objetos
std::vector&lt;Vertex&gt; vertices;

// Llenamos el array con los v&eacute;rtices de todos los objetos
for (const auto&amp; object : objects) {
    vertices.insert(vertices.end(), object.vertices.begin(), object.vertices.end());
}

// Creamos un buffer de v&eacute;rtices
D3D11_BUFFER_DESC bufferDesc = {};
bufferDesc.Usage = D3D11_USAGE_DEFAULT;
bufferDesc.ByteWidth = sizeof(Vertex) * vertices.size();
bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;

D3D11_SUBRESOURCE_DATA initData = {};
initData.pSysMem = vertices.data();

ID3D11Buffer* vertexBuffer;
device-&gt;CreateBuffer(&amp;bufferDesc, &amp;initData, &amp;vertexBuffer);

// Dibujamos todos los objetos en una sola llamada
UINT stride = sizeof(Vertex);
UINT offset = 0;
context-&gt;IASetVertexBuffers(0, 1, &amp;vertexBuffer, &amp;stride, &amp;offset);
context-&gt;Draw(vertices.size(), 0);</pre></div><div class='content'></div><h1><p>Instancing</p>
</h1>
<div class='content'><p>Instancing permite dibujar múltiples instancias de un objeto con una sola llamada de dibujo, lo que es muy eficiente para objetos repetitivos como árboles o rocas en un paisaje.</p>
</div><h2><p>Ejemplo de Instancing</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gU3Vwb25nYW1vcyBxdWUgdGVuZW1vcyB1biBidWZmZXIgZGUgdsOpcnRpY2VzIHBhcmEgdW4gc29sbyBvYmpldG8KSUQzRDExQnVmZmVyKiB2ZXJ0ZXhCdWZmZXI7CgovLyBDcmVhbW9zIHVuIGJ1ZmZlciBkZSBpbnN0YW5jaWFzCnN0cnVjdCBJbnN0YW5jZURhdGEgewogICAgRGlyZWN0WDo6WE1NQVRSSVggd29ybGRNYXRyaXg7Cn07CgpzdGQ6OnZlY3RvcjxJbnN0YW5jZURhdGE+IGluc3RhbmNlczsKZm9yIChjb25zdCBhdXRvJiB0cmFuc2Zvcm0gOiB0cmFuc2Zvcm1zKSB7CiAgICBpbnN0YW5jZXMucHVzaF9iYWNrKHsgdHJhbnNmb3JtIH0pOwp9CgpEM0QxMV9CVUZGRVJfREVTQyBpbnN0YW5jZUJ1ZmZlckRlc2MgPSB7fTsKaW5zdGFuY2VCdWZmZXJEZXNjLlVzYWdlID0gRDNEMTFfVVNBR0VfREVGQVVMVDsKaW5zdGFuY2VCdWZmZXJEZXNjLkJ5dGVXaWR0aCA9IHNpemVvZihJbnN0YW5jZURhdGEpICogaW5zdGFuY2VzLnNpemUoKTsKaW5zdGFuY2VCdWZmZXJEZXNjLkJpbmRGbGFncyA9IEQzRDExX0JJTkRfVkVSVEVYX0JVRkZFUjsKCkQzRDExX1NVQlJFU09VUkNFX0RBVEEgaW5zdGFuY2VEYXRhID0ge307Cmluc3RhbmNlRGF0YS5wU3lzTWVtID0gaW5zdGFuY2VzLmRhdGEoKTsKCklEM0QxMUJ1ZmZlciogaW5zdGFuY2VCdWZmZXI7CmRldmljZS0+Q3JlYXRlQnVmZmVyKCZpbnN0YW5jZUJ1ZmZlckRlc2MsICZpbnN0YW5jZURhdGEsICZpbnN0YW5jZUJ1ZmZlcik7CgovLyBEaWJ1amFtb3MgdG9kYXMgbGFzIGluc3RhbmNpYXMgZW4gdW5hIHNvbGEgbGxhbWFkYQpVSU5UIHN0cmlkZXNbMl0gPSB7IHNpemVvZihWZXJ0ZXgpLCBzaXplb2YoSW5zdGFuY2VEYXRhKSB9OwpVSU5UIG9mZnNldHNbMl0gPSB7IDAsIDAgfTsKSUQzRDExQnVmZmVyKiBidWZmZXJzWzJdID0geyB2ZXJ0ZXhCdWZmZXIsIGluc3RhbmNlQnVmZmVyIH07CmNvbnRleHQtPklBU2V0VmVydGV4QnVmZmVycygwLCAyLCBidWZmZXJzLCBzdHJpZGVzLCBvZmZzZXRzKTsKY29udGV4dC0+RHJhd0luc3RhbmNlZCh2ZXJ0ZXhDb3VudCwgaW5zdGFuY2VzLnNpemUoKSwgMCwgMCk7"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Supongamos que tenemos un buffer de v&eacute;rtices para un solo objeto
ID3D11Buffer* vertexBuffer;

// Creamos un buffer de instancias
struct InstanceData {
    DirectX::XMMATRIX worldMatrix;
};

std::vector&lt;InstanceData&gt; instances;
for (const auto&amp; transform : transforms) {
    instances.push_back({ transform });
}

D3D11_BUFFER_DESC instanceBufferDesc = {};
instanceBufferDesc.Usage = D3D11_USAGE_DEFAULT;
instanceBufferDesc.ByteWidth = sizeof(InstanceData) * instances.size();
instanceBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;

D3D11_SUBRESOURCE_DATA instanceData = {};
instanceData.pSysMem = instances.data();

ID3D11Buffer* instanceBuffer;
device-&gt;CreateBuffer(&amp;instanceBufferDesc, &amp;instanceData, &amp;instanceBuffer);

// Dibujamos todas las instancias en una sola llamada
UINT strides[2] = { sizeof(Vertex), sizeof(InstanceData) };
UINT offsets[2] = { 0, 0 };
ID3D11Buffer* buffers[2] = { vertexBuffer, instanceBuffer };
context-&gt;IASetVertexBuffers(0, 2, buffers, strides, offsets);
context-&gt;DrawInstanced(vertexCount, instances.size(), 0, 0);</pre></div><div class='content'></div><h1><p>Level of Detail (LOD)</p>
</h1>
<div class='content'><p>LOD es una técnica que ajusta el nivel de detalle de los modelos en función de su distancia a la cámara. Los objetos lejanos se renderizan con menos detalle para ahorrar recursos.</p>
</div><h2><p>Ejemplo de LOD</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gU3Vwb25nYW1vcyBxdWUgdGVuZW1vcyBkaWZlcmVudGVzIHZlcnNpb25lcyBkZSB1biBtb2RlbG8gcGFyYSBkaWZlcmVudGVzIG5pdmVsZXMgZGUgZGV0YWxsZQpNb2RlbCBoaWdoRGV0YWlsTW9kZWw7Ck1vZGVsIG1lZGl1bURldGFpbE1vZGVsOwpNb2RlbCBsb3dEZXRhaWxNb2RlbDsKCmZsb2F0IGRpc3RhbmNlVG9DYW1lcmEgPSBDYWxjdWxhdGVEaXN0YW5jZVRvQ2FtZXJhKG9iamVjdFBvc2l0aW9uKTsKCmlmIChkaXN0YW5jZVRvQ2FtZXJhIDwgNTAuMGYpIHsKICAgIGhpZ2hEZXRhaWxNb2RlbC5SZW5kZXIoY29udGV4dCk7Cn0gZWxzZSBpZiAoZGlzdGFuY2VUb0NhbWVyYSA8IDEwMC4wZikgewogICAgbWVkaXVtRGV0YWlsTW9kZWwuUmVuZGVyKGNvbnRleHQpOwp9IGVsc2UgewogICAgbG93RGV0YWlsTW9kZWwuUmVuZGVyKGNvbnRleHQpOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Supongamos que tenemos diferentes versiones de un modelo para diferentes niveles de detalle
Model highDetailModel;
Model mediumDetailModel;
Model lowDetailModel;

float distanceToCamera = CalculateDistanceToCamera(objectPosition);

if (distanceToCamera &lt; 50.0f) {
    highDetailModel.Render(context);
} else if (distanceToCamera &lt; 100.0f) {
    mediumDetailModel.Render(context);
} else {
    lowDetailModel.Render(context);
}</pre></div><div class='content'></div><h1><p>Culling</p>
</h1>
<div class='content'><p>Culling es la técnica de omitir el renderizado de objetos que no son visibles para la cámara, como aquellos que están fuera del campo de visión o detrás de otros objetos.</p>
</div><h2><p>Ejemplo de Culling</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gU3Vwb25nYW1vcyBxdWUgdGVuZW1vcyB1bmEgZnVuY2nDs24gcXVlIGRldGVybWluYSBzaSB1biBvYmpldG8gZXN0w6EgZGVudHJvIGRlbCBmcnVzdHVtIGRlIGxhIGPDoW1hcmEKYm9vbCBJc0luVmlld0ZydXN0dW0oY29uc3QgQm91bmRpbmdCb3gmIGJvdW5kaW5nQm94KTsKCmZvciAoY29uc3QgYXV0byYgb2JqZWN0IDogb2JqZWN0cykgewogICAgaWYgKElzSW5WaWV3RnJ1c3R1bShvYmplY3QuYm91bmRpbmdCb3gpKSB7CiAgICAgICAgb2JqZWN0LlJlbmRlcihjb250ZXh0KTsKICAgIH0KfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Supongamos que tenemos una funci&oacute;n que determina si un objeto est&aacute; dentro del frustum de la c&aacute;mara
bool IsInViewFrustum(const BoundingBox&amp; boundingBox);

for (const auto&amp; object : objects) {
    if (IsInViewFrustum(object.boundingBox)) {
        object.Render(context);
    }
}</pre></div><div class='content'></div><h1><p>Optimización de Shaders</p>
</h1>
<div class='content'><p>Los shaders pueden ser una fuente significativa de sobrecarga. Optimizar los shaders puede mejorar considerablemente el rendimiento.</p>
</div><h2><p>Consejos para Optimizar Shaders</p>
</h2>
<div class='content'><ol>
<li><strong>Minimizar el uso de operaciones costosas</strong>: Evitar operaciones como la raíz cuadrada y las divisiones.</li>
<li><strong>Reducir el número de instrucciones</strong>: Simplificar los cálculos y reutilizar resultados.</li>
<li><strong>Usar texturas comprimidas</strong>: Reducir el tamaño de las texturas para mejorar el rendimiento.</li>
</ol>
</div><h2><p>Ejemplo de Shader Optimizado</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gU2hhZGVyIG5vIG9wdGltaXphZG8KZmxvYXQ0IFBTKFZlcnRleE91dHB1dCBpbnB1dCkgOiBTVl9UYXJnZXQgewogICAgZmxvYXQgZGlzdGFuY2UgPSBsZW5ndGgoaW5wdXQucG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbik7CiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMCAvIChkaXN0YW5jZSAqIGRpc3RhbmNlKTsKICAgIHJldHVybiBpbnB1dC5jb2xvciAqIGF0dGVudWF0aW9uOwp9CgovLyBTaGFkZXIgb3B0aW1pemFkbwpmbG9hdDQgUFMoVmVydGV4T3V0cHV0IGlucHV0KSA6IFNWX1RhcmdldCB7CiAgICBmbG9hdCBkaXN0YW5jZVNxdWFyZWQgPSBkb3QoaW5wdXQucG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiwgaW5wdXQucG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbik7CiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMCAvIGRpc3RhbmNlU3F1YXJlZDsKICAgIHJldHVybiBpbnB1dC5jb2xvciAqIGF0dGVudWF0aW9uOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Shader no optimizado
float4 PS(VertexOutput input) : SV_Target {
    float distance = length(input.position - cameraPosition);
    float attenuation = 1.0 / (distance * distance);
    return input.color * attenuation;
}

// Shader optimizado
float4 PS(VertexOutput input) : SV_Target {
    float distanceSquared = dot(input.position - cameraPosition, input.position - cameraPosition);
    float attenuation = 1.0 / distanceSquared;
    return input.color * attenuation;
}</pre></div><div class='content'></div><h1><p>Compresión de Texturas</p>
</h1>
<div class='content'><p>La compresión de texturas reduce el tamaño de las texturas, lo que puede mejorar el rendimiento al reducir la cantidad de memoria y ancho de banda necesarios.</p>
</div><h2><p>Ejemplo de Compresión de Texturas</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gU3Vwb25nYW1vcyBxdWUgZXN0YW1vcyBjYXJnYW5kbyB1bmEgdGV4dHVyYSBjb21wcmltaWRhCklEM0QxMVRleHR1cmUyRCogdGV4dHVyZTsKRDNEWDExQ3JlYXRlVGV4dHVyZUZyb21GaWxlKGRldmljZSwgTCJ0ZXh0dXJlLmRkcyIsIG51bGxwdHIsIG51bGxwdHIsIChJRDNEMTFSZXNvdXJjZSoqKSZ0ZXh0dXJlLCBudWxscHRyKTsKCi8vIENyZWFtb3MgdW5hIHZpc3RhIGRlIHNoYWRlciByZXNvdXJjZSBwYXJhIGxhIHRleHR1cmEKRDNEMTFfU0hBREVSX1JFU09VUkNFX1ZJRVdfREVTQyBzcnZEZXNjID0ge307CnNydkRlc2MuRm9ybWF0ID0gRFhHSV9GT1JNQVRfQkMxX1VOT1JNOwpzcnZEZXNjLlZpZXdEaW1lbnNpb24gPSBEM0QxMV9TUlZfRElNRU5TSU9OX1RFWFRVUkUyRDsKc3J2RGVzYy5UZXh0dXJlMkQuTW9zdERldGFpbGVkTWlwID0gMDsKc3J2RGVzYy5UZXh0dXJlMkQuTWlwTGV2ZWxzID0gLTE7CgpJRDNEMTFTaGFkZXJSZXNvdXJjZVZpZXcqIHRleHR1cmVWaWV3OwpkZXZpY2UtPkNyZWF0ZVNoYWRlclJlc291cmNlVmlldyh0ZXh0dXJlLCAmc3J2RGVzYywgJnRleHR1cmVWaWV3KTs="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Supongamos que estamos cargando una textura comprimida
ID3D11Texture2D* texture;
D3DX11CreateTextureFromFile(device, L&quot;texture.dds&quot;, nullptr, nullptr, (ID3D11Resource**)&amp;texture, nullptr);

// Creamos una vista de shader resource para la textura
D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
srvDesc.Format = DXGI_FORMAT_BC1_UNORM;
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
srvDesc.Texture2D.MostDetailedMip = 0;
srvDesc.Texture2D.MipLevels = -1;

ID3D11ShaderResourceView* textureView;
device-&gt;CreateShaderResourceView(texture, &amp;srvDesc, &amp;textureView);</pre></div><div class='content'></div><h1><p>Ejercicio Práctico</p>
</h1>
<div class='content'></div><h2><p>Ejercicio</p>
</h2>
<div class='content'><ol>
<li>Implementa una aplicación DirectX que renderice múltiples instancias de un objeto utilizando instancing.</li>
<li>Optimiza los shaders utilizados en la aplicación para mejorar el rendimiento.</li>
<li>Implementa culling para omitir el renderizado de objetos que no son visibles.</li>
</ol>
</div><h2><p>Solución</p>
</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Ly8gSW1wbGVtZW50YWNpw7NuIGRlIGluc3RhbmNpbmcKLy8gU3Vwb25nYW1vcyBxdWUgdGVuZW1vcyB1biBidWZmZXIgZGUgdsOpcnRpY2VzIHBhcmEgdW4gc29sbyBvYmpldG8KSUQzRDExQnVmZmVyKiB2ZXJ0ZXhCdWZmZXI7CgovLyBDcmVhbW9zIHVuIGJ1ZmZlciBkZSBpbnN0YW5jaWFzCnN0cnVjdCBJbnN0YW5jZURhdGEgewogICAgRGlyZWN0WDo6WE1NQVRSSVggd29ybGRNYXRyaXg7Cn07CgpzdGQ6OnZlY3RvcjxJbnN0YW5jZURhdGE+IGluc3RhbmNlczsKZm9yIChjb25zdCBhdXRvJiB0cmFuc2Zvcm0gOiB0cmFuc2Zvcm1zKSB7CiAgICBpbnN0YW5jZXMucHVzaF9iYWNrKHsgdHJhbnNmb3JtIH0pOwp9CgpEM0QxMV9CVUZGRVJfREVTQyBpbnN0YW5jZUJ1ZmZlckRlc2MgPSB7fTsKaW5zdGFuY2VCdWZmZXJEZXNjLlVzYWdlID0gRDNEMTFfVVNBR0VfREVGQVVMVDsKaW5zdGFuY2VCdWZmZXJEZXNjLkJ5dGVXaWR0aCA9IHNpemVvZihJbnN0YW5jZURhdGEpICogaW5zdGFuY2VzLnNpemUoKTsKaW5zdGFuY2VCdWZmZXJEZXNjLkJpbmRGbGFncyA9IEQzRDExX0JJTkRfVkVSVEVYX0JVRkZFUjsKCkQzRDExX1NVQlJFU09VUkNFX0RBVEEgaW5zdGFuY2VEYXRhID0ge307Cmluc3RhbmNlRGF0YS5wU3lzTWVtID0gaW5zdGFuY2VzLmRhdGEoKTsKCklEM0QxMUJ1ZmZlciogaW5zdGFuY2VCdWZmZXI7CmRldmljZS0+Q3JlYXRlQnVmZmVyKCZpbnN0YW5jZUJ1ZmZlckRlc2MsICZpbnN0YW5jZURhdGEsICZpbnN0YW5jZUJ1ZmZlcik7CgovLyBEaWJ1amFtb3MgdG9kYXMgbGFzIGluc3RhbmNpYXMgZW4gdW5hIHNvbGEgbGxhbWFkYQpVSU5UIHN0cmlkZXNbMl0gPSB7IHNpemVvZihWZXJ0ZXgpLCBzaXplb2YoSW5zdGFuY2VEYXRhKSB9OwpVSU5UIG9mZnNldHNbMl0gPSB7IDAsIDAgfTsKSUQzRDExQnVmZmVyKiBidWZmZXJzWzJdID0geyB2ZXJ0ZXhCdWZmZXIsIGluc3RhbmNlQnVmZmVyIH07CmNvbnRleHQtPklBU2V0VmVydGV4QnVmZmVycygwLCAyLCBidWZmZXJzLCBzdHJpZGVzLCBvZmZzZXRzKTsKY29udGV4dC0+RHJhd0luc3RhbmNlZCh2ZXJ0ZXhDb3VudCwgaW5zdGFuY2VzLnNpemUoKSwgMCwgMCk7CgovLyBJbXBsZW1lbnRhY2nDs24gZGUgY3VsbGluZwpmb3IgKGNvbnN0IGF1dG8mIG9iamVjdCA6IG9iamVjdHMpIHsKICAgIGlmIChJc0luVmlld0ZydXN0dW0ob2JqZWN0LmJvdW5kaW5nQm94KSkgewogICAgICAgIG9iamVjdC5SZW5kZXIoY29udGV4dCk7CiAgICB9Cn0KCi8vIE9wdGltaXphY2nDs24gZGUgc2hhZGVycwpmbG9hdDQgUFMoVmVydGV4T3V0cHV0IGlucHV0KSA6IFNWX1RhcmdldCB7CiAgICBmbG9hdCBkaXN0YW5jZVNxdWFyZWQgPSBkb3QoaW5wdXQucG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiwgaW5wdXQucG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbik7CiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMCAvIGRpc3RhbmNlU3F1YXJlZDsKICAgIHJldHVybiBpbnB1dC5jb2xvciAqIGF0dGVudWF0aW9uOwp9"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>// Implementaci&oacute;n de instancing
// Supongamos que tenemos un buffer de v&eacute;rtices para un solo objeto
ID3D11Buffer* vertexBuffer;

// Creamos un buffer de instancias
struct InstanceData {
    DirectX::XMMATRIX worldMatrix;
};

std::vector&lt;InstanceData&gt; instances;
for (const auto&amp; transform : transforms) {
    instances.push_back({ transform });
}

D3D11_BUFFER_DESC instanceBufferDesc = {};
instanceBufferDesc.Usage = D3D11_USAGE_DEFAULT;
instanceBufferDesc.ByteWidth = sizeof(InstanceData) * instances.size();
instanceBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;

D3D11_SUBRESOURCE_DATA instanceData = {};
instanceData.pSysMem = instances.data();

ID3D11Buffer* instanceBuffer;
device-&gt;CreateBuffer(&amp;instanceBufferDesc, &amp;instanceData, &amp;instanceBuffer);

// Dibujamos todas las instancias en una sola llamada
UINT strides[2] = { sizeof(Vertex), sizeof(InstanceData) };
UINT offsets[2] = { 0, 0 };
ID3D11Buffer* buffers[2] = { vertexBuffer, instanceBuffer };
context-&gt;IASetVertexBuffers(0, 2, buffers, strides, offsets);
context-&gt;DrawInstanced(vertexCount, instances.size(), 0, 0);

// Implementaci&oacute;n de culling
for (const auto&amp; object : objects) {
    if (IsInViewFrustum(object.boundingBox)) {
        object.Render(context);
    }
}

// Optimizaci&oacute;n de shaders
float4 PS(VertexOutput input) : SV_Target {
    float distanceSquared = dot(input.position - cameraPosition, input.position - cameraPosition);
    float attenuation = 1.0 / distanceSquared;
    return input.color * attenuation;
}</pre></div><div class='content'></div><h1><p>Conclusión</p>
</h1>
<div class='content'><p>En esta sección, hemos explorado diversas técnicas para optimizar el rendimiento de renderizado en aplicaciones DirectX. Desde el batching y el instancing hasta la optimización de shaders y la compresión de texturas, cada técnica puede contribuir significativamente a mejorar la eficiencia de nuestras aplicaciones. Asegúrate de aplicar estas técnicas en tus proyectos para lograr un rendimiento óptimo y una experiencia de usuario fluida. En el próximo módulo, profundizaremos en la gestión de memoria para optimizar aún más nuestras aplicaciones DirectX.</p>
</div><div class='row navigation'>
	<div class='col-2'>
					<a href='06-01-profiling-debugging' title="Perfilado y Depuración">&#x25C4;Anterior</a>
			</div>
	<div class='col-8 text-center'>
			</div>
	<div class='col-2 text-end'>
					<a href='06-03-memory-management' title="Gestión de Memoria">Siguiente &#x25BA;</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Usamos cookies para mejorar tu experiencia de uso y ofrecer contenidos adaptados a tus intereses.
    <a href="#" id="btn_accept_cookies" class="button">Aceptar</a>
    <a href="/cookies">Mas información</a>
</div>	

	</div>    
</body>
</html>
