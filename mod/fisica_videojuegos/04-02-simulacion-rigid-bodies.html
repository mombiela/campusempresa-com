<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación de Rigid Bodies</title>

    <link rel="alternate" href="https://campusempresa.com/mod/fisica_videojuegos/04-02-simulacion-rigid-bodies" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/fisica_videojuegos/04-02-simulacio-rigid-bodies" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/fisica_videojuegos/04-02-rigid-bodies-simulation" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Construyendo la sociedad de hoy y del mañana</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
										<a href="https://enterprisecampus.net/mod/fisica_videojuegos/04-02-rigid-bodies-simulation" class="px-2">EN</a></b>
				|
				<b class="px-2">ES</b>
				|
				<a href="https://campusempresa.cat/mod/fisica_videojuegos/04-02-simulacio-rigid-bodies" class="px-2">CA</a>
								</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">El Proyecto</a>
				<a href="/about">Sobre nosotros</a>
				<a href="/contribute">Contribuir</a>
				<a href="/donate">Donaciones</a>
				<a href="/licence">Licencia</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
								<div class='row navigation'>
	<div class='col-2'>
					<a href='04-01-introduccion-rigid-bodies' title="Introducción a Rigid Bodies">&#x25C4;Anterior</a>
			</div>
	<div class='col-8 text-center'>
					<a href="./"><h2 style="text-decoration:underline">Simulación de Rigid Bodies</h2></a>
			</div>
	<div class='col-2 text-end'>
					<a href='04-03-interacciones-rigid-bodies' title="Interacciones entre Rigid Bodies">Siguiente &#x25BA;</a>
			</div>
</div>
<div class='content'><p>La simulación de rigid bodies (cuerpos rígidos) es una parte fundamental en la física de videojuegos, ya que permite crear interacciones realistas entre objetos sólidos. En este tema, exploraremos los conceptos clave, las ecuaciones y las técnicas utilizadas para simular cuerpos rígidos en un entorno de videojuego.</p>
</div><h1>Conceptos Básicos</h1>
<div class='content'></div><h2>¿Qué es un Rigid Body?</h2>
<div class='content'><p>Un rigid body es un objeto que no se deforma bajo la acción de fuerzas. En otras palabras, la distancia entre cualquier par de puntos en el objeto permanece constante. Esto simplifica enormemente los cálculos físicos, ya que no necesitamos considerar deformaciones internas.</p>
</div><h2>Propiedades de un Rigid Body</h2>
<div class='content'><ol>
<li><strong>Masa (m):</strong> La cantidad de materia en el objeto.</li>
<li><strong>Centro de Masa (CM):</strong> El punto donde se puede considerar que toda la masa del objeto está concentrada.</li>
<li><strong>Momento de Inercia (I):</strong> La resistencia del objeto a cambiar su estado de rotación.</li>
<li><strong>Velocidad Lineal (v):</strong> La velocidad del centro de masa.</li>
<li><strong>Velocidad Angular (ω):</strong> La velocidad de rotación alrededor del centro de masa.</li>
</ol>
</div><h1>Ecuaciones de Movimiento</h1>
<div class='content'></div><h2>Movimiento Lineal</h2>
<div class='content'><p>El movimiento lineal de un rigid body se describe mediante la segunda ley de Newton:</p>
<p>\[ F = m \cdot a \]</p>
<p>Donde:</p>
<ul>
<li>\( F \) es la fuerza aplicada.</li>
<li>\( m \) es la masa del objeto.</li>
<li>\( a \) es la aceleración.</li>
</ul>
</div><h2>Movimiento Rotacional</h2>
<div class='content'><p>El movimiento rotacional se describe mediante la ecuación del momento de fuerza (torque):</p>
<p>\[ \tau = I \cdot \alpha \]</p>
<p>Donde:</p>
<ul>
<li>\( \tau \) es el torque aplicado.</li>
<li>\( I \) es el momento de inercia.</li>
<li>\( \alpha \) es la aceleración angular.</li>
</ul>
</div><h1>Simulación en Motores de Física</h1>
<div class='content'></div><h2>Integración Numérica</h2>
<div class='content'><p>Para simular el movimiento de rigid bodies, utilizamos métodos de integración numérica para actualizar las posiciones y velocidades de los objetos en cada frame del juego.</p>
<h4>Método de Euler</h4>
<p>El método de Euler es uno de los métodos más simples para la integración numérica:</p>
<p>\[ v_{t+1} = v_t + a \cdot \Delta t \]
\[ x_{t+1} = x_t + v_{t+1} \cdot \Delta t \]</p>
<p>Donde:</p>
<ul>
<li>\( v \) es la velocidad.</li>
<li>\( a \) es la aceleración.</li>
<li>\( x \) es la posición.</li>
<li>\( \Delta t \) es el intervalo de tiempo entre frames.</li>
</ul>
</div><h2>Ejemplo Práctico</h2>
<div class='content'><p>A continuación, se presenta un ejemplo de código en C++ utilizando un motor de física básico para simular un rigid body:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8Y21hdGg+CgpzdHJ1Y3QgVmVjdG9yMiB7CiAgICBmbG9hdCB4LCB5OwogICAgCiAgICBWZWN0b3IyIG9wZXJhdG9yKyhjb25zdCBWZWN0b3IyJiBvdGhlcikgY29uc3QgewogICAgICAgIHJldHVybiB7eCArIG90aGVyLngsIHkgKyBvdGhlci55fTsKICAgIH0KICAgIAogICAgVmVjdG9yMiBvcGVyYXRvciooZmxvYXQgc2NhbGFyKSBjb25zdCB7CiAgICAgICAgcmV0dXJuIHt4ICogc2NhbGFyLCB5ICogc2NhbGFyfTsKICAgIH0KfTsKCnN0cnVjdCBSaWdpZEJvZHkgewogICAgVmVjdG9yMiBwb3NpdGlvbjsKICAgIFZlY3RvcjIgdmVsb2NpdHk7CiAgICBmbG9hdCBtYXNzOwogICAgCiAgICB2b2lkIGFwcGx5Rm9yY2UoY29uc3QgVmVjdG9yMiYgZm9yY2UsIGZsb2F0IGRlbHRhVGltZSkgewogICAgICAgIFZlY3RvcjIgYWNjZWxlcmF0aW9uID0ge2ZvcmNlLnggLyBtYXNzLCBmb3JjZS55IC8gbWFzc307CiAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbiAqIGRlbHRhVGltZTsKICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVsb2NpdHkgKiBkZWx0YVRpbWU7CiAgICB9Cn07CgppbnQgbWFpbigpIHsKICAgIFJpZ2lkQm9keSBib2R5ID0ge3swLCAwfSwgezAsIDB9LCAxLjBmfTsgLy8gSW5pY2lhbGl6YWNpw7NuIGRlbCByaWdpZCBib2R5CiAgICBWZWN0b3IyIGZvcmNlID0gezEwLCAwfTsgLy8gRnVlcnphIGFwbGljYWRhCiAgICBmbG9hdCBkZWx0YVRpbWUgPSAwLjAxNmY7IC8vIFRpZW1wbyBlbnRyZSBmcmFtZXMgKGFwcm94aW1hZGFtZW50ZSA2MCBGUFMpCiAgICAKICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMTAwOyArK2kpIHsKICAgICAgICBib2R5LmFwcGx5Rm9yY2UoZm9yY2UsIGRlbHRhVGltZSk7CiAgICAgICAgc3RkOjpjb3V0IDw8ICJQb3NpdGlvbiBhdCBmcmFtZSAiIDw8IGkgPDwgIjogKCIgPDwgYm9keS5wb3NpdGlvbi54IDw8ICIsICIgPDwgYm9keS5wb3NpdGlvbi55IDw8ICIpXG4iOwogICAgfQogICAgCiAgICByZXR1cm4gMDsKfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;iostream&gt;
#include &lt;cmath&gt;

struct Vector2 {
    float x, y;
    
    Vector2 operator+(const Vector2&amp; other) const {
        return {x + other.x, y + other.y};
    }
    
    Vector2 operator*(float scalar) const {
        return {x * scalar, y * scalar};
    }
};

struct RigidBody {
    Vector2 position;
    Vector2 velocity;
    float mass;
    
    void applyForce(const Vector2&amp; force, float deltaTime) {
        Vector2 acceleration = {force.x / mass, force.y / mass};
        velocity = velocity + acceleration * deltaTime;
        position = position + velocity * deltaTime;
    }
};

int main() {
    RigidBody body = {{0, 0}, {0, 0}, 1.0f}; // Inicializaci&oacute;n del rigid body
    Vector2 force = {10, 0}; // Fuerza aplicada
    float deltaTime = 0.016f; // Tiempo entre frames (aproximadamente 60 FPS)
    
    for (int i = 0; i &lt; 100; ++i) {
        body.applyForce(force, deltaTime);
        std::cout &lt;&lt; &quot;Position at frame &quot; &lt;&lt; i &lt;&lt; &quot;: (&quot; &lt;&lt; body.position.x &lt;&lt; &quot;, &quot; &lt;&lt; body.position.y &lt;&lt; &quot;)\n&quot;;
    }
    
    return 0;
}</pre></div><div class='content'></div><h2>Explicación del Código</h2>
<div class='content'><ol>
<li><strong>Estructura <code>Vector2</code>:</strong> Representa un vector en 2D con operaciones básicas de suma y multiplicación por un escalar.</li>
<li><strong>Estructura <code>RigidBody</code>:</strong> Contiene la posición, velocidad y masa del cuerpo rígido. El método <code>applyForce</code> aplica una fuerza al cuerpo y actualiza su posición y velocidad utilizando el método de Euler.</li>
<li><strong>Función <code>main</code>:</strong> Inicializa un <code>RigidBody</code>, aplica una fuerza constante y simula su movimiento durante 100 frames, imprimiendo la posición en cada frame.</li>
</ol>
</div><h1>Ejercicio Práctico</h1>
<div class='content'></div><h2>Ejercicio 1: Simulación de un Rigid Body en 2D</h2>
<div class='content'><p>Modifica el código anterior para incluir la simulación de la rotación de un rigid body. Debes considerar el torque y el momento de inercia.</p>
<h4>Solución</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8Y21hdGg+CgpzdHJ1Y3QgVmVjdG9yMiB7CiAgICBmbG9hdCB4LCB5OwogICAgCiAgICBWZWN0b3IyIG9wZXJhdG9yKyhjb25zdCBWZWN0b3IyJiBvdGhlcikgY29uc3QgewogICAgICAgIHJldHVybiB7eCArIG90aGVyLngsIHkgKyBvdGhlci55fTsKICAgIH0KICAgIAogICAgVmVjdG9yMiBvcGVyYXRvciooZmxvYXQgc2NhbGFyKSBjb25zdCB7CiAgICAgICAgcmV0dXJuIHt4ICogc2NhbGFyLCB5ICogc2NhbGFyfTsKICAgIH0KfTsKCnN0cnVjdCBSaWdpZEJvZHkgewogICAgVmVjdG9yMiBwb3NpdGlvbjsKICAgIFZlY3RvcjIgdmVsb2NpdHk7CiAgICBmbG9hdCBtYXNzOwogICAgZmxvYXQgYW5nbGU7IC8vIMOBbmd1bG8gZGUgcm90YWNpw7NuCiAgICBmbG9hdCBhbmd1bGFyVmVsb2NpdHk7IC8vIFZlbG9jaWRhZCBhbmd1bGFyCiAgICBmbG9hdCBtb21lbnRPZkluZXJ0aWE7IC8vIE1vbWVudG8gZGUgaW5lcmNpYQogICAgCiAgICB2b2lkIGFwcGx5Rm9yY2UoY29uc3QgVmVjdG9yMiYgZm9yY2UsIGZsb2F0IGRlbHRhVGltZSkgewogICAgICAgIFZlY3RvcjIgYWNjZWxlcmF0aW9uID0ge2ZvcmNlLnggLyBtYXNzLCBmb3JjZS55IC8gbWFzc307CiAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbiAqIGRlbHRhVGltZTsKICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVsb2NpdHkgKiBkZWx0YVRpbWU7CiAgICB9CiAgICAKICAgIHZvaWQgYXBwbHlUb3JxdWUoZmxvYXQgdG9ycXVlLCBmbG9hdCBkZWx0YVRpbWUpIHsKICAgICAgICBmbG9hdCBhbmd1bGFyQWNjZWxlcmF0aW9uID0gdG9ycXVlIC8gbW9tZW50T2ZJbmVydGlhOwogICAgICAgIGFuZ3VsYXJWZWxvY2l0eSA9IGFuZ3VsYXJWZWxvY2l0eSArIGFuZ3VsYXJBY2NlbGVyYXRpb24gKiBkZWx0YVRpbWU7CiAgICAgICAgYW5nbGUgPSBhbmdsZSArIGFuZ3VsYXJWZWxvY2l0eSAqIGRlbHRhVGltZTsKICAgIH0KfTsKCmludCBtYWluKCkgewogICAgUmlnaWRCb2R5IGJvZHkgPSB7ezAsIDB9LCB7MCwgMH0sIDEuMGYsIDAsIDAsIDEuMGZ9OyAvLyBJbmljaWFsaXphY2nDs24gZGVsIHJpZ2lkIGJvZHkKICAgIFZlY3RvcjIgZm9yY2UgPSB7MTAsIDB9OyAvLyBGdWVyemEgYXBsaWNhZGEKICAgIGZsb2F0IHRvcnF1ZSA9IDUuMGY7IC8vIFRvcnF1ZSBhcGxpY2FkbwogICAgZmxvYXQgZGVsdGFUaW1lID0gMC4wMTZmOyAvLyBUaWVtcG8gZW50cmUgZnJhbWVzIChhcHJveGltYWRhbWVudGUgNjAgRlBTKQogICAgCiAgICBmb3IgKGludCBpID0gMDsgaSA8IDEwMDsgKytpKSB7CiAgICAgICAgYm9keS5hcHBseUZvcmNlKGZvcmNlLCBkZWx0YVRpbWUpOwogICAgICAgIGJvZHkuYXBwbHlUb3JxdWUodG9ycXVlLCBkZWx0YVRpbWUpOwogICAgICAgIHN0ZDo6Y291dCA8PCAiUG9zaXRpb24gYXQgZnJhbWUgIiA8PCBpIDw8ICI6ICgiIDw8IGJvZHkucG9zaXRpb24ueCA8PCAiLCAiIDw8IGJvZHkucG9zaXRpb24ueSA8PCAiKSwgQW5nbGU6ICIgPDwgYm9keS5hbmdsZSA8PCAiXG4iOwogICAgfQogICAgCiAgICByZXR1cm4gMDsKfQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;iostream&gt;
#include &lt;cmath&gt;

struct Vector2 {
    float x, y;
    
    Vector2 operator+(const Vector2&amp; other) const {
        return {x + other.x, y + other.y};
    }
    
    Vector2 operator*(float scalar) const {
        return {x * scalar, y * scalar};
    }
};

struct RigidBody {
    Vector2 position;
    Vector2 velocity;
    float mass;
    float angle; // &Aacute;ngulo de rotaci&oacute;n
    float angularVelocity; // Velocidad angular
    float momentOfInertia; // Momento de inercia
    
    void applyForce(const Vector2&amp; force, float deltaTime) {
        Vector2 acceleration = {force.x / mass, force.y / mass};
        velocity = velocity + acceleration * deltaTime;
        position = position + velocity * deltaTime;
    }
    
    void applyTorque(float torque, float deltaTime) {
        float angularAcceleration = torque / momentOfInertia;
        angularVelocity = angularVelocity + angularAcceleration * deltaTime;
        angle = angle + angularVelocity * deltaTime;
    }
};

int main() {
    RigidBody body = {{0, 0}, {0, 0}, 1.0f, 0, 0, 1.0f}; // Inicializaci&oacute;n del rigid body
    Vector2 force = {10, 0}; // Fuerza aplicada
    float torque = 5.0f; // Torque aplicado
    float deltaTime = 0.016f; // Tiempo entre frames (aproximadamente 60 FPS)
    
    for (int i = 0; i &lt; 100; ++i) {
        body.applyForce(force, deltaTime);
        body.applyTorque(torque, deltaTime);
        std::cout &lt;&lt; &quot;Position at frame &quot; &lt;&lt; i &lt;&lt; &quot;: (&quot; &lt;&lt; body.position.x &lt;&lt; &quot;, &quot; &lt;&lt; body.position.y &lt;&lt; &quot;), Angle: &quot; &lt;&lt; body.angle &lt;&lt; &quot;\n&quot;;
    }
    
    return 0;
}</pre></div><div class='content'></div><h2>Explicación de la Solución</h2>
<div class='content'><ol>
<li><strong>Nuevas Propiedades:</strong> Se añadieron <code>angle</code>, <code>angularVelocity</code> y <code>momentOfInertia</code> a la estructura <code>RigidBody</code>.</li>
<li><strong>Método <code>applyTorque</code>:</strong> Aplica un torque al cuerpo rígido y actualiza su ángulo y velocidad angular utilizando el método de Euler.</li>
<li><strong>Función <code>main</code>:</strong> Aplica tanto una fuerza como un torque al cuerpo rígido y simula su movimiento y rotación durante 100 frames.</li>
</ol>
</div><h1>Conclusión</h1>
<div class='content'><p>En esta sección, hemos cubierto los conceptos básicos y las ecuaciones necesarias para simular rigid bodies en un entorno de videojuego. Hemos visto cómo aplicar fuerzas y torques, y cómo utilizar métodos de integración numérica para actualizar las posiciones y velocidades de los objetos. Con estos fundamentos, estarás preparado para implementar simulaciones de cuerpos rígidos más complejas y realistas en tus proyectos de videojuegos.</p>
</div><div class='row navigation'>
	<div class='col-2'>
					<a href='04-01-introduccion-rigid-bodies' title="Introducción a Rigid Bodies">&#x25C4;Anterior</a>
			</div>
	<div class='col-8 text-center'>
			</div>
	<div class='col-2 text-end'>
					<a href='04-03-interacciones-rigid-bodies' title="Interacciones entre Rigid Bodies">Siguiente &#x25BA;</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Aceptar</a>
    <a href="/cookies">Mas información</a>
</div>	

	</div>    
</body>
</html>
