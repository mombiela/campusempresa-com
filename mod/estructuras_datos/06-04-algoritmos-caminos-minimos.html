<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos de Caminos Mínimos</title>

    <link rel="alternate" href="https://campusempresa.com/mod/estructuras_datos/06-04-algoritmos-caminos-minimos" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/estructuras_datos/06-04-algoritmes-camins-minims" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/estructuras_datos/06-04-shortest-path-algorithms" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="/js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-12 col-md-6 p-2 p-md-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-12 col-md-6 p-2 p-md-0 text-end">
				<a href="https://enterprisecampus.net/mod/estructuras_datos/06-04-shortest-path-algorithms" class="px-2">EN</a></b>
	|
	<b class="px-2">ES</b>
	|
	<a href="https://campusempresa.cat/mod/estructuras_datos/06-04-algoritmes-camins-minims" class="px-2">CA</a>
<br>
			<cite>Construyendo la sociedad de hoy y del mañana</cite>
		</div>
	</div>
</div>
<div id="subheader" class="container-xxl">
	<div class="row">
		<div class="col-12 p-2 p-md-0 m-0 text-end">
			<a href="/objective">El Proyecto</a> | 
<a href="/about">Sobre nosotros</a> | 
<a href="/contribute">Contribuir</a> | 
<a href="/donate">Donaciones</a> | 
<a href="/licence">Licencia</a>
		</div>
	</div>
</div>

<div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				 					<a href="/categ/languages">Lenguajes de Programación</a>
				 					<a href="/categ/frameworks">Frameworks y Librerías</a>
				 					<a href="/categ/tech-tools">Herramientas Técnicas</a>
				 					<a href="/categ/foundations">Fundamentos Teóricos</a>
				 					<a href="/categ/soft-skills">Habilidades Sociales</a>
							</div>
		</div>
	</div>
</div>
		
<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
				<div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='06-03-algoritmos-busqueda-grafos' title="Algoritmos de Búsqueda en Grafos">
				<span class="d-none d-md-inline">&#x25C4; Anterior</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
					<a href="./"><h2 style="text-decoration:underline">Algoritmos de Caminos Mínimos</h2></a>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='06-05-aplicaciones-grafos' title="Aplicaciones de los Grafos">
				<span class="d-none d-md-inline">Siguiente &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>
<div class='content'><p>En este tema, aprenderemos sobre los algoritmos más comunes para encontrar el camino más corto en un grafo. Estos algoritmos son fundamentales en diversas aplicaciones, desde la navegación GPS hasta la optimización de redes.</p>
</div><h1><p>Conceptos Clave</p>
</h1>
<div class='content'></div><h2><p>Definiciones Básicas</p>
</h2>
<div class='content'><ol>
<li><strong>Grafo</strong>: Conjunto de nodos (vértices) y aristas (conexiones entre nodos).</li>
<li><strong>Peso</strong>: Valor asociado a una arista que representa el costo, distancia o tiempo.</li>
<li><strong>Camino Mínimo</strong>: Camino entre dos nodos que tiene el menor peso total.</li>
</ol>
</div><h2><p>Tipos de Grafos</p>
</h2>
<div class='content'><ol>
<li><strong>Grafo Dirigido</strong>: Las aristas tienen una dirección.</li>
<li><strong>Grafo No Dirigido</strong>: Las aristas no tienen dirección.</li>
<li><strong>Grafo Ponderado</strong>: Las aristas tienen pesos asociados.</li>
</ol>
</div><h1><p>Algoritmos Principales</p>
</h1>
<div class='content'></div><h2><p>Algoritmo de Dijkstra</p>
</h2>
<div class='content'><p>El algoritmo de Dijkstra encuentra el camino más corto desde un nodo origen a todos los demás nodos en un grafo ponderado y dirigido.</p>
<h4>Pasos del Algoritmo</h4>
<ol>
<li>Inicializar la distancia al nodo origen como 0 y a todos los demás nodos como infinito.</li>
<li>Marcar todos los nodos como no visitados.</li>
<li>Seleccionar el nodo no visitado con la distancia más pequeña.</li>
<li>Actualizar la distancia de los nodos adyacentes.</li>
<li>Marcar el nodo actual como visitado.</li>
<li>Repetir los pasos 3-5 hasta que todos los nodos hayan sido visitados.</li>
</ol>
<h4>Ejemplo en Python</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0KToKICAgICMgSW5pY2lhbGl6YXIgZGlzdGFuY2lhcyB5IGNvbGEgZGUgcHJpb3JpZGFkCiAgICBkaXN0YW5jZXMgPSB7bm9kZTogZmxvYXQoJ2luZmluaXR5JykgZm9yIG5vZGUgaW4gZ3JhcGh9CiAgICBkaXN0YW5jZXNbc3RhcnRdID0gMAogICAgcHJpb3JpdHlfcXVldWUgPSBbKDAsIHN0YXJ0KV0KICAgIAogICAgd2hpbGUgcHJpb3JpdHlfcXVldWU6CiAgICAgICAgY3VycmVudF9kaXN0YW5jZSwgY3VycmVudF9ub2RlID0gaGVhcHEuaGVhcHBvcChwcmlvcml0eV9xdWV1ZSkKICAgICAgICAKICAgICAgICBpZiBjdXJyZW50X2Rpc3RhbmNlID4gZGlzdGFuY2VzW2N1cnJlbnRfbm9kZV06CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgCiAgICAgICAgZm9yIG5laWdoYm9yLCB3ZWlnaHQgaW4gZ3JhcGhbY3VycmVudF9ub2RlXS5pdGVtcygpOgogICAgICAgICAgICBkaXN0YW5jZSA9IGN1cnJlbnRfZGlzdGFuY2UgKyB3ZWlnaHQKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIGRpc3RhbmNlIDwgZGlzdGFuY2VzW25laWdoYm9yXToKICAgICAgICAgICAgICAgIGRpc3RhbmNlc1tuZWlnaGJvcl0gPSBkaXN0YW5jZQogICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2gocHJpb3JpdHlfcXVldWUsIChkaXN0YW5jZSwgbmVpZ2hib3IpKQogICAgCiAgICByZXR1cm4gZGlzdGFuY2VzCgojIEVqZW1wbG8gZGUgdXNvCmdyYXBoID0gewogICAgJ0EnOiB7J0InOiAxLCAnQyc6IDR9LAogICAgJ0InOiB7J0EnOiAxLCAnQyc6IDIsICdEJzogNX0sCiAgICAnQyc6IHsnQSc6IDQsICdCJzogMiwgJ0QnOiAxfSwKICAgICdEJzogeydCJzogNSwgJ0MnOiAxfQp9CgpwcmludChkaWprc3RyYShncmFwaCwgJ0EnKSk="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def dijkstra(graph, start):
    # Inicializar distancias y cola de prioridad
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        
        if current_distance &gt; distances[current_node]:
            continue
        
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            
            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Ejemplo de uso
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

print(dijkstra(graph, 'A'))</pre></div><div class='content'></div><h2><p>Algoritmo de Bellman-Ford</p>
</h2>
<div class='content'><p>El algoritmo de Bellman-Ford también encuentra el camino más corto desde un nodo origen a todos los demás nodos, pero puede manejar grafos con aristas de peso negativo.</p>
<h4>Pasos del Algoritmo</h4>
<ol>
<li>Inicializar la distancia al nodo origen como 0 y a todos los demás nodos como infinito.</li>
<li>Relajar todas las aristas repetidamente.</li>
<li>Verificar si hay ciclos de peso negativo.</li>
</ol>
<h4>Ejemplo en Python</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGJlbGxtYW5fZm9yZChncmFwaCwgc3RhcnQpOgogICAgZGlzdGFuY2VzID0ge25vZGU6IGZsb2F0KCdpbmZpbml0eScpIGZvciBub2RlIGluIGdyYXBofQogICAgZGlzdGFuY2VzW3N0YXJ0XSA9IDAKICAgIAogICAgZm9yIF8gaW4gcmFuZ2UobGVuKGdyYXBoKSAtIDEpOgogICAgICAgIGZvciBub2RlIGluIGdyYXBoOgogICAgICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtub2RlXS5pdGVtcygpOgogICAgICAgICAgICAgICAgaWYgZGlzdGFuY2VzW25vZGVdICsgd2VpZ2h0IDwgZGlzdGFuY2VzW25laWdoYm9yXToKICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZXNbbmVpZ2hib3JdID0gZGlzdGFuY2VzW25vZGVdICsgd2VpZ2h0CiAgICAKICAgIGZvciBub2RlIGluIGdyYXBoOgogICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGlmIGRpc3RhbmNlc1tub2RlXSArIHdlaWdodCA8IGRpc3RhbmNlc1tuZWlnaGJvcl06CiAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCJHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlLXdlaWdodCBjeWNsZSIpCiAgICAKICAgIHJldHVybiBkaXN0YW5jZXMKCiMgRWplbXBsbyBkZSB1c28KZ3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDEsICdDJzogNH0sCiAgICAnQic6IHsnQSc6IDEsICdDJzogMiwgJ0QnOiA1fSwKICAgICdDJzogeydBJzogNCwgJ0InOiAyLCAnRCc6IDF9LAogICAgJ0QnOiB7J0InOiA1LCAnQyc6IDF9Cn0KCnByaW50KGJlbGxtYW5fZm9yZChncmFwaCwgJ0EnKSk="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def bellman_ford(graph, start):
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    
    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node].items():
                if distances[node] + weight &lt; distances[neighbor]:
                    distances[neighbor] = distances[node] + weight
    
    for node in graph:
        for neighbor, weight in graph[node].items():
            if distances[node] + weight &lt; distances[neighbor]:
                raise ValueError(&quot;Graph contains a negative-weight cycle&quot;)
    
    return distances

# Ejemplo de uso
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

print(bellman_ford(graph, 'A'))</pre></div><div class='content'></div><h2><p>Algoritmo de Floyd-Warshall</p>
</h2>
<div class='content'><p>El algoritmo de Floyd-Warshall encuentra el camino más corto entre todos los pares de nodos en un grafo ponderado.</p>
<h4>Pasos del Algoritmo</h4>
<ol>
<li>Crear una matriz de distancias y inicializarla con los pesos de las aristas.</li>
<li>Para cada par de nodos (i, j), actualizar la distancia usando un nodo intermedio k.</li>
</ol>
<h4>Ejemplo en Python</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGZsb3lkX3dhcnNoYWxsKGdyYXBoKToKICAgIG5vZGVzID0gbGlzdChncmFwaC5rZXlzKCkpCiAgICBkaXN0ID0ge25vZGU6IHtub2RlOiBmbG9hdCgnaW5maW5pdHknKSBmb3Igbm9kZSBpbiBub2Rlc30gZm9yIG5vZGUgaW4gbm9kZXN9CiAgICAKICAgIGZvciBub2RlIGluIG5vZGVzOgogICAgICAgIGRpc3Rbbm9kZV1bbm9kZV0gPSAwCiAgICAKICAgIGZvciBub2RlIGluIGdyYXBoOgogICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3Rbbm9kZV1bbmVpZ2hib3JdID0gd2VpZ2h0CiAgICAKICAgIGZvciBrIGluIG5vZGVzOgogICAgICAgIGZvciBpIGluIG5vZGVzOgogICAgICAgICAgICBmb3IgaiBpbiBub2RlczoKICAgICAgICAgICAgICAgIGlmIGRpc3RbaV1bal0gPiBkaXN0W2ldW2tdICsgZGlzdFtrXVtqXToKICAgICAgICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal0KICAgIAogICAgcmV0dXJuIGRpc3QKCiMgRWplbXBsbyBkZSB1c28KZ3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDEsICdDJzogNH0sCiAgICAnQic6IHsnQSc6IDEsICdDJzogMiwgJ0QnOiA1fSwKICAgICdDJzogeydBJzogNCwgJ0InOiAyLCAnRCc6IDF9LAogICAgJ0QnOiB7J0InOiA1LCAnQyc6IDF9Cn0KCnByaW50KGZsb3lkX3dhcnNoYWxsKGdyYXBoKSk="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def floyd_warshall(graph):
    nodes = list(graph.keys())
    dist = {node: {node: float('infinity') for node in nodes} for node in nodes}
    
    for node in nodes:
        dist[node][node] = 0
    
    for node in graph:
        for neighbor, weight in graph[node].items():
            dist[node][neighbor] = weight
    
    for k in nodes:
        for i in nodes:
            for j in nodes:
                if dist[i][j] &gt; dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# Ejemplo de uso
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

print(floyd_warshall(graph))</pre></div><div class='content'></div><h1><p>Ejercicios Prácticos</p>
</h1>
<div class='content'></div><h2><p>Ejercicio 1: Implementar Dijkstra</p>
</h2>
<div class='content'><p>Implementa el algoritmo de Dijkstra para el siguiente grafo y encuentra el camino más corto desde el nodo 'A' al nodo 'D'.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Z3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDIsICdDJzogNX0sCiAgICAnQic6IHsnQSc6IDIsICdDJzogNiwgJ0QnOiAxfSwKICAgICdDJzogeydBJzogNSwgJ0InOiA2LCAnRCc6IDN9LAogICAgJ0QnOiB7J0InOiAxLCAnQyc6IDN9Cn0="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>graph = {
    'A': {'B': 2, 'C': 5},
    'B': {'A': 2, 'C': 6, 'D': 1},
    'C': {'A': 5, 'B': 6, 'D': 3},
    'D': {'B': 1, 'C': 3}
}</pre></div><div class='content'></div><h2><p>Ejercicio 2: Detectar Ciclos Negativos con Bellman-Ford</p>
</h2>
<div class='content'><p>Modifica el grafo del ejemplo de Bellman-Ford para incluir una arista de peso negativo y verifica si el algoritmo detecta el ciclo negativo.</p>
</div><h2><p>Ejercicio 3: Matriz de Distancias con Floyd-Warshall</p>
</h2>
<div class='content'><p>Usa el algoritmo de Floyd-Warshall para encontrar la matriz de distancias para el siguiente grafo.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Z3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDMsICdDJzogOH0sCiAgICAnQic6IHsnQSc6IDMsICdDJzogMiwgJ0QnOiA1fSwKICAgICdDJzogeydBJzogOCwgJ0InOiAyLCAnRCc6IDF9LAogICAgJ0QnOiB7J0InOiA1LCAnQyc6IDF9Cn0="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>graph = {
    'A': {'B': 3, 'C': 8},
    'B': {'A': 3, 'C': 2, 'D': 5},
    'C': {'A': 8, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}</pre></div><div class='content'></div><h1><p>Soluciones</p>
</h1>
<div class='content'></div><h2><p>Solución al Ejercicio 1</p>
</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHJpbnQoZGlqa3N0cmEoZ3JhcGgsICdBJykp"))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>print(dijkstra(graph, 'A'))</pre></div><div class='content'></div><h2><p>Solución al Ejercicio 2</p>
</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Z3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDEsICdDJzogNH0sCiAgICAnQic6IHsnQSc6IDEsICdDJzogMiwgJ0QnOiA1fSwKICAgICdDJzogeydBJzogNCwgJ0InOiAyLCAnRCc6IDF9LAogICAgJ0QnOiB7J0InOiA1LCAnQyc6IDEsICdBJzogLTEwfQp9Cgp0cnk6CiAgICBwcmludChiZWxsbWFuX2ZvcmQoZ3JhcGgsICdBJykpCmV4Y2VwdCBWYWx1ZUVycm9yIGFzIGU6CiAgICBwcmludChlKQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1, 'A': -10}
}

try:
    print(bellman_ford(graph, 'A'))
except ValueError as e:
    print(e)</pre></div><div class='content'></div><h2><p>Solución al Ejercicio 3</p>
</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHJpbnQoZmxveWRfd2Fyc2hhbGwoZ3JhcGgpKQ=="))));alert("¡Copiado!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>print(floyd_warshall(graph))</pre></div><div class='content'></div><h1><p>Conclusión</p>
</h1>
<div class='content'><p>En esta sección, hemos aprendido sobre los algoritmos más comunes para encontrar caminos mínimos en grafos: Dijkstra, Bellman-Ford y Floyd-Warshall. Cada uno tiene sus propias ventajas y limitaciones, y es importante elegir el algoritmo adecuado según las características del grafo y el problema a resolver. Con estos conocimientos, estás preparado para abordar problemas complejos de optimización y navegación en grafos.</p>
</div><div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='06-03-algoritmos-busqueda-grafos' title="Algoritmos de Búsqueda en Grafos">
				<span class="d-none d-md-inline">&#x25C4; Anterior</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='06-05-aplicaciones-grafos' title="Aplicaciones de los Grafos">
				<span class="d-none d-md-inline">Siguiente &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicidad</h1>
			<p>Este espacio está destinado a publicidad.</p>
			<p>Si quieres ser patrocinador, contáctanos para incluir enlaces en esta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>¡Gracias por colaborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Todos los derechos reservados</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Usamos cookies para mejorar tu experiencia de uso y ofrecer contenidos adaptados a tus intereses.
    <a href="#" id="btn_accept_cookies" class="button">Aceptar</a>
    <a href="/cookies">Mas información</a>
</div>	

	</div>    
</body>
</html>
